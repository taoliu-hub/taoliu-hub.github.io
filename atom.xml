<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>TaoLiu-Blog</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-05-12T07:38:59.153Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Tao Liu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA数据结构和算法</title>
    <link href="http://example.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    <id>http://example.com/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</id>
    <published>2022-05-12T09:35:21.866Z</published>
    <updated>2022-05-12T07:38:59.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA数据结构和算法："><a href="#JAVA数据结构和算法：" class="headerlink" title="JAVA数据结构和算法："></a>JAVA数据结构和算法：</h1><hr><p><code>数据结构分类：线性结构和非线性结构：</code></p><h1 id="问题一："><a href="#问题一：" class="headerlink" title="问题一："></a>问题一：</h1><p><code>什么是线性和非线性；</code></p><p>个人的理解是：数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构；<br>线性结构包括：数组，链表，队列，栈；<br>非线性结构包括：树，图，表；</p><p>详解：<br>一.线性结构</p><p>1.数组<br>特点：我们都知道数组中的元素在内存中连续存储的，可以根据是下标快速访问元素，因此，查询速度很快，然而插入和删除时，需要对元素移动空间，比较慢。<br>数组使用场景：频繁查询，很少增加和删除的情况。</p><p>2.链表<br>特点：元素可以不连续内存中，是以索引将数据联系起来的，当查询元素的时候需要从头开始查询，所以效率比较低，然而添加和删除的只需要修改索引就可以了<br>链表使用场景：少查询，需要频繁的插入或删除情况</p><p>3.队列<br>特点：先进先出，<br>队列使用场景：多线程阻塞队列管理非常有用</p><p>4.栈<br>特点：先进后出，就像一个箱子，<br>栈使用场景：实现递归以及表示式</p><p>5.数组与链表的区别<br>数组连续，链表不连续（从数据存储形式来说）<br>数组内存静态分配，链表动态分配<br>数组查询复杂度O(1)，链表查询复杂度O(n)<br>数组添加或删除，复杂度O(n),链表添加删除，复杂度O(1)<br>数组从栈中分配内存。链表从堆中分配内存。</p><p><code>补充：时间复杂度O(1), O(n), O(logn), O(nlogn)指什么 </code><br>  描述算法复杂度时,常用o(1), o(n), o(logn), o(nlogn)表示对应算法的时间复杂度，是算法的时空复杂度的表示。不仅仅用于表示时间复杂度，也用于表示空间复杂度。<br>O后面的括号中有一个函数，指明某个算法的耗时&#x2F;耗空间与数据增长量之间的关系。其中的n代表输入数据的量。</p><blockquote><p>O(1)：<br>  是最低的时空复杂度了，代表耗时&#x2F;耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时&#x2F;耗空间都不变。 <code>哈希算法</code>就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话）</p></blockquote><blockquote><p> O(n)：<br> 代表数据量增大几倍，耗时也增大几倍。比如常见的<code>遍历算法</code>。</p></blockquote><blockquote><p>O(n^2)：<br>  代表数据量增大n倍时，耗时增大n的平方倍，这是比线性更高的时间复杂度。比如<code>冒泡排序</code>，就是典型的O(n^2)的算法，对n个数排序，需要扫描n×n次。</p></blockquote><blockquote><p>O(logn)：<br>  代表当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。<code>二分查找</code>就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。</p></blockquote><blockquote><p>O(nlogn)：<br>  代表n乘以logn，当数据增大256倍时，耗时增大256*8&#x3D;2048倍。这个复杂度高于线性低于平方。<code>归并排序</code>就是O(nlogn)的时间复杂度。</p></blockquote><hr><h1 id="问题二："><a href="#问题二：" class="headerlink" title="问题二："></a>问题二：</h1><p>c1）插入排序（直接插入排序、希尔排序） </p><blockquote><p>2）交换排序（冒泡排序、快速排序）<br>3）选择排序（直接选择排序、堆排序）<br>4）归并排序<br>5）分配排序（基数排序）<br><code>特点:</code><br>所需辅助空间最多：归并排序<br>所需辅助空间最少：堆排序<br>平均速度最快：快速排序<br>不稳定：快速排序，希尔排序，堆排序</p></blockquote><ul><li>直接插入排序<blockquote><p>基本思想：在要排序的一组数中，假设前面(n-1)[n&gt;&#x3D;2] 个数已经是排好顺序的，现在要把第n 个数插到前面的有序数中，使得这 n个数也是排好顺序的。如此反复循环，直到全部排好顺序</p></blockquote></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">     * 插入排序法 </span><br><span class="line">     *  </span><br><span class="line">     * @param datas </span><br><span class="line">     */  </span><br><span class="line">    public static int[] sortInsert(int[] datas) &#123;  </span><br><span class="line">        for (int i = 1; i &lt; datas.length; i++) &#123;  </span><br><span class="line">            int j = i - 1;  </span><br><span class="line">            AlgorithmUtil.temp = datas[i];  </span><br><span class="line">            for (; j &gt;= 0 &amp;&amp; AlgorithmUtil.temp &lt; datas[j]; j--) &#123;  </span><br><span class="line">                datas[j + 1] = datas[j];  </span><br><span class="line">            &#125;  </span><br><span class="line">            datas[j + 1] = AlgorithmUtil.temp;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return datas;  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><ul><li>简单选择排序 <blockquote><p>基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。</p></blockquote></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">    * 选择排序 </span><br><span class="line">    *  </span><br><span class="line">    * @return </span><br><span class="line">    */  </span><br><span class="line">   public static int[] sortSelect(int[] datas) &#123;  </span><br><span class="line">       for (int i = 0; i &lt; datas.length; i++) &#123;  </span><br><span class="line">           int index = i;  </span><br><span class="line">           for (int j = i + 1; j &lt; datas.length; j++) &#123;  </span><br><span class="line">               if (datas[j] &lt; datas[index])  </span><br><span class="line">                   index = j;  </span><br><span class="line">           &#125;  </span><br><span class="line">           if (i != index)  </span><br><span class="line">               AlgorithmUtil.swap(datas, i, index);  </span><br><span class="line">       &#125;  </span><br><span class="line">       return datas;  </span><br><span class="line">   &#125;  </span><br></pre></td></tr></table></figure><ul><li>冒泡排序<blockquote><p>基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。</p></blockquote></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">     * 冒泡排序 </span><br><span class="line">     *  </span><br><span class="line">     * @return </span><br><span class="line">     */  </span><br><span class="line">    public static int[] sortBubble(int[] datas) &#123;  </span><br><span class="line">        for (int i = 0; i &lt; datas.length - 1; i++) &#123;  </span><br><span class="line">            for (int j = 0; j &lt; datas.length - 1 - i; j++) &#123;  </span><br><span class="line">                if (datas[j] &gt; datas[j + 1])  </span><br><span class="line">                    AlgorithmUtil.swap(datas, j, j + 1);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        return datas;  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><ul><li>快速排序<blockquote><p>基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。</p></blockquote></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">/** </span><br><span class="line">     * 快速排序；分割数组 </span><br><span class="line">     *  </span><br><span class="line">     * @param datas </span><br><span class="line">     */  </span><br><span class="line">    public static int QuickPartition(int[] datas, int left, int right) &#123;  </span><br><span class="line">        int pivot = datas[left];  </span><br><span class="line">        while (left &lt; right) &#123;  </span><br><span class="line">            while (left &lt; right &amp;&amp; datas[right] &gt;= pivot)  </span><br><span class="line">                --right;  </span><br><span class="line">            datas[left] = datas[right]; // 将比枢轴小的元素移到低端，此时right位相当于空，等待低位比pivotkey大的数补上  </span><br><span class="line">            while (left &lt; right &amp;&amp; datas[left] &lt;= pivot)  </span><br><span class="line">                ++left;  </span><br><span class="line">            datas[right] = datas[left]; // 将比枢轴大的元素移到高端，此时left位相当于空，等待高位比pivotkey小的数补上  </span><br><span class="line">        &#125;  </span><br><span class="line">        datas[left] = pivot; // 当left == right，完成一趟快速排序，此时left位相当于空，等待pivotkey补上  </span><br><span class="line">        return left;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    /** </span><br><span class="line">     * 快速排序；递归返回数组 </span><br><span class="line">     *  </span><br><span class="line">     * @param datas </span><br><span class="line">     */  </span><br><span class="line">    public static int[] sortQuick(int[] datas, int left, int right) &#123;  </span><br><span class="line">        if (left &lt; right) &#123;  </span><br><span class="line">            int data = QuickPartition(datas, left, right);  </span><br><span class="line">            sortQuick(datas, left, data - 1);  </span><br><span class="line">            sortQuick(datas, data + 1, right);  </span><br><span class="line">        &#125;  </span><br><span class="line">        return datas;  </span><br><span class="line">    &#125;  </span><br></pre></td></tr></table></figure><ul><li>1.冒泡算法，2.选择算法，3.快速算法。4.插入算法，5.希尔算法，6.堆算法<blockquote><p>基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。</p></blockquote></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public class AlgorithmUtil &#123;  </span><br><span class="line"></span><br><span class="line">public static int temp,index = 0;  </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * 临时值交换 </span><br><span class="line"> *  </span><br><span class="line"> * @param datas </span><br><span class="line"> *            数组 </span><br><span class="line"> * @param i </span><br><span class="line"> * @param j </span><br><span class="line"> */  </span><br><span class="line">public static void swap(int[] datas, int i, int j) &#123;  </span><br><span class="line">    temp = datas[i];  </span><br><span class="line">    datas[i] = datas[j];  </span><br><span class="line">    datas[j] = temp;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">/** </span><br><span class="line"> * 扩充数组长度 </span><br><span class="line"> *  </span><br><span class="line"> * @param datas </span><br><span class="line"> * @param value </span><br><span class="line"> * @return </span><br><span class="line"> */  </span><br><span class="line">public static int[] expandArray(int[] datas, int value) &#123;  </span><br><span class="line">    if (datas.length &lt;= index) &#123;  </span><br><span class="line">        int[] arrays = new int[datas.length * 2];  </span><br><span class="line">        System.arraycopy(datas, 0, arrays, 0, datas.length);  </span><br><span class="line">        datas = arrays;  </span><br><span class="line">    &#125;  </span><br><span class="line">    datas[index] = value;  </span><br><span class="line">    index++;  </span><br><span class="line">    return datas;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JAVA数据结构和算法：&quot;&gt;&lt;a href=&quot;#JAVA数据结构和算法：&quot; class=&quot;headerlink&quot; title=&quot;JAVA数据结构和算法：&quot;&gt;&lt;/a&gt;JAVA数据结构和算法：&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;&lt;code&gt;数据结构分类：线性结构和非线性结构：&lt;</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="JAVA数据结构和算法" scheme="http://example.com/tags/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>DB</title>
    <link href="http://example.com/blog/DB/oracle/db2/"/>
    <id>http://example.com/blog/DB/oracle/db2/</id>
    <published>2022-05-12T09:35:21.862Z</published>
    <updated>2022-05-12T06:36:52.871Z</updated>
    
    <content type="html"><![CDATA[<p>DB</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;DB&lt;/p&gt;
</summary>
      
    
    
    
    <category term="DB" scheme="http://example.com/categories/DB/"/>
    
    <category term="oracle" scheme="http://example.com/categories/DB/oracle/"/>
    
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://example.com/blog/DB/mysql/test/"/>
    <id>http://example.com/blog/DB/mysql/test/</id>
    <published>2022-05-12T09:35:21.857Z</published>
    <updated>2022-05-12T07:43:03.103Z</updated>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;test&lt;/p&gt;
</summary>
      
    
    
    
    <category term="DB" scheme="http://example.com/categories/DB/"/>
    
    <category term="mysql" scheme="http://example.com/categories/DB/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql1</title>
    <link href="http://example.com/blog/DB/mysql/mysql/"/>
    <id>http://example.com/blog/DB/mysql/mysql/</id>
    <published>2022-05-12T09:35:21.855Z</published>
    <updated>2022-05-12T07:43:55.226Z</updated>
    
    <content type="html"><![CDATA[<p>test</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;test&lt;/p&gt;
</summary>
      
    
    
    
    <category term="DB" scheme="http://example.com/categories/DB/"/>
    
    <category term="mysql" scheme="http://example.com/categories/DB/mysql/"/>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/blog/index/"/>
    <id>http://example.com/blog/index/</id>
    <published>2022-05-12T09:35:21.848Z</published>
    <updated>2022-05-12T07:46:31.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Welcome-TaoLiu’s-Blog"><a href="#Welcome-TaoLiu’s-Blog" class="headerlink" title="Welcome TaoLiu’s Blog"></a>Welcome TaoLiu’s Blog</h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Welcome-TaoLiu’s-Blog&quot;&gt;&lt;a href=&quot;#Welcome-TaoLiu’s-Blog&quot; class=&quot;headerlink&quot; title=&quot;Welcome TaoLiu’s Blog&quot;&gt;&lt;/a&gt;Welcome TaoLiu’s Blog&lt;/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>cloud基础</title>
    <link href="http://example.com/blog/Cloud/Cloud%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/blog/Cloud/Cloud%E5%9F%BA%E7%A1%80/</id>
    <published>2022-05-12T09:35:21.844Z</published>
    <updated>2022-05-12T06:39:01.563Z</updated>
    
    <content type="html"><![CDATA[<p>cloud基础</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;cloud基础&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Cloud" scheme="http://example.com/categories/Cloud/"/>
    
    
  </entry>
  
  <entry>
    <title>cloud原理</title>
    <link href="http://example.com/blog/Cloud/cloud%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/blog/Cloud/cloud%E5%8E%9F%E7%90%86/</id>
    <published>2022-05-12T09:35:21.842Z</published>
    <updated>2022-05-12T06:51:13.611Z</updated>
    
    <content type="html"><![CDATA[<p>cloud原理</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;cloud原理&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Cloud" scheme="http://example.com/categories/Cloud/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello hexo</title>
    <link href="http://example.com/blog/hello-hexo/"/>
    <id>http://example.com/blog/hello-hexo/</id>
    <published>2022-05-12T09:35:21.839Z</published>
    <updated>2022-05-12T09:03:14.613Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
