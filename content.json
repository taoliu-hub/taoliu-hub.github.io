{"pages":[{"title":"About","date":"2022-05-12T08:53:51.333Z","path":"about/index.html","text":"Welcome TaoLiu’s Blog"},{"title":"Tags","date":"2022-05-12T08:42:52.567Z","path":"tags/index.html","text":""},{"title":"Categories","date":"2022-05-12T08:42:52.543Z","path":"categories/index.html","text":""}],"posts":[{"title":"SpringCloud系列14-总结","date":"2022-05-13T08:31:30.061Z","path":"blog/Cloud/SpringCloud/SpringCloud系列14-总结/","text":"多个微服务:12345678910&lt;modules&gt; &lt;module&gt;eureka-server&lt;/module&gt; &lt;module&gt;product-data-service&lt;/module&gt; &lt;module&gt;product-view-service-ribbon&lt;/module&gt; &lt;module&gt;product-view-service-feign&lt;/module&gt; &lt;module&gt;config-server&lt;/module&gt; &lt;module&gt;hystrix-dashboard&lt;/module&gt; &lt;module&gt;turbine&lt;/module&gt; &lt;module&gt;productServiceZuul&lt;/module&gt;&lt;/modules&gt; 端口号总结:微服务： eureka-server: 8761 product-data-service: 8001,8002,8003 product-view-service-ribbon: 8010 product-view-service-feign: 8012, 8013, 8014 hystrix-dashboard: 8020 turbine: 8021 config-server: 8030 zuul: 8040 第三方: zipkin:9411 rabbitMQ: 5672","tags":[],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"},{"name":"SpringCloud","slug":"Cloud/SpringCloud","permalink":"http://example.com/categories/Cloud/SpringCloud/"}]},{"title":"SpringCloud系列13-网关Zuul","date":"2022-05-13T08:31:03.246Z","path":"blog/Cloud/SpringCloud/SpringCloud系列13-网关Zuul/","text":"问题：为何要用网关? 我们现在有两种微服务，分别是数据微服务和视图微服务。它们有可能放在不同的 ip 地址上，有可能是不同的端口。 为了访问他们，就需要记录这些地址和端口。 而地址和端口都可能会变化，这就增加了访问者的负担。这个时候，我们就可以用网关来解决这个问题。 如图所示，我们只需要记住网关的地址和端口号就行了： 如果要访问数据服务，访问地址 http://ip:port/api-data/products 即可。 如果要访问视图服务，访问地址 http://ip:port/api-view/products 即可 创建子项目： zuulpom.xml：12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;spring-cloud-parent&lt;/artifactId&gt; &lt;groupId&gt;cn.peach&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../spring-cloud-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;productServiceZuul&lt;/artifactId&gt; &lt;name&gt;productServiceZuul&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ProductServiceZuulApplication.java:12345678910111213141516171819202122232425package cn.peach;import cn.hutool.core.util.NetUtil;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.netflix.zuul.EnableZuulProxy;@SpringBootApplication@EnableZuulProxy@EnableEurekaClient@EnableDiscoveryClientpublic class ProductServiceZuulApplication&#123; public static void main( String[] args ) &#123; int port = 8040; if(!NetUtil.isUsableLocalPort(port)) &#123; System.err.printf(&quot;端口%d被占用了，无法启动%n&quot;, port ); System.exit(1); &#125; new SpringApplicationBuilder(ProductServiceZuulApplication.class).properties(&quot;server.port=&quot; + port).run(args); &#125;&#125; application.yml:配置文件，进行了路由映射 12345678zuul: routes: api-a: path: /api-data/** serviceId: PRODUCT-DATA-SERVICE api-b: path: /api-view/** serviceId: PRODUCT-VIEW-SERVICE-FEIGN 完整代码： 123456789101112131415eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/spring: application: name: product-service-zuulzuul: routes: api-a: path: /api-data/** serviceId: PRODUCT-DATA-SERVICE api-b: path: /api-view/** serviceId: PRODUCT-VIEW-SERVICE-FEIGN 启动： 首先挨个运行 EurekaServerApplication, ConfigServerApplication, ProductDataServiceApplication， ProductViewServiceFeignApplication。 然后启动 ProductServiceZuulApplication 接着访问地址: http://localhost:8040/api-data/products http://localhost:8040/api-view/products 这样就可以访问数据微服务和视微服务集群了，并且无需去记住那么多ip地址和端口号了。","tags":[],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"},{"name":"SpringCloud","slug":"Cloud/SpringCloud","permalink":"http://example.com/categories/Cloud/SpringCloud/"}]},{"title":"SpringCloud系列12-断路器聚合监控","date":"2022-05-13T08:30:43.961Z","path":"blog/Cloud/SpringCloud/SpringCloud系列12-断路器聚合监控/","text":"需求:前面是针对一个微服务的断路器监控，但是微服务通常会是多个实例组成的一个集群。 倘若集群里的实例比较多，难道要挨个挨个去监控这些实例吗？ 何况有时候，根据集群的需要，会动态增加或者减少实例，监控起来就更麻烦了。 为了方便监控集群里的多个实例，springCloud 提供了一个 turbine 项目，它的作用是把一个集群里的多个实例汇聚在一个 turbine里，这个然后再在 断路器监控里查看这个 turbine, 这样就能够在集群层面进行监控了。 创建子项目： turbinepom.xml:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;spring-cloud-parent&lt;/artifactId&gt; &lt;groupId&gt;cn.peach&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../spring-cloud-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;turbine&lt;/artifactId&gt; &lt;name&gt;turbine&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-turbine&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ProductServiceTurbineApplication.java1234567891011121314151617181920package cn.peach;import cn.hutool.core.util.NetUtil;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.cloud.netflix.turbine.EnableTurbine;@SpringBootApplication@EnableTurbinepublic class ProductServiceTurbineApplication &#123; public static void main(String[] args) &#123; int port = 8021; if(!NetUtil.isUsableLocalPort(port)) &#123; System.err.printf(&quot;端口%d被占用了，无法启动%n&quot;, port ); System.exit(1); &#125; new SpringApplicationBuilder(ProductServiceTurbineApplication.class).properties(&quot;server.port=&quot; + port).run(args); &#125;&#125; application.yml配置信息，主要是：appConfig: product-view-service-feign, 这就表示它会把所有微服务名称是product-view-service-feign 的实例信息都收集起来。 1234567891011121314spring: application.name: turbineturbine: aggregator: clusterConfig: default # 指定聚合哪些集群，多个使用&quot;,&quot;分割，默认为default。可使用http://.../turbine.stream?cluster=&#123;clusterConfig之一&#125;访问 appConfig: product-view-service-feign ### 配置Eureka中的serviceId列表，表明监控哪些服务 clusterNameExpression: new String(&quot;default&quot;) # 1. clusterNameExpression指定集群名称，默认表达式appName；此时：turbine.aggregator.clusterConfig需要配置想要监控的应用名称 # 2. 当clusterNameExpression:default时，turbine.aggregator.clusterConfig可以不写，因为默认就是default # 3. 当clusterNameExpression:metadata[&#x27;cluster&#x27;]时，假设想要监控的应用配置了eureka.instance.metadata-map.cluster: ABC，则需要配置，同时turbine.aggregator.clusterConfig: ABCeureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/","tags":[],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"},{"name":"SpringCloud","slug":"Cloud/SpringCloud","permalink":"http://example.com/categories/Cloud/SpringCloud/"}]},{"title":"SpringCloud系列11-断路器监控","date":"2022-05-13T08:30:21.970Z","path":"blog/Cloud/SpringCloud/SpringCloud系列11-断路器监控/","text":"需求:断路器，是当数据服务不可用的时候， 断路器就会发挥作用。那么数据服务什么时候可用，什么时候不可用，如何监控这个事情呢？ 我们就要用到 断路器监控 来可视化掌控这个情况了。 创建子项目：hystrix-dashboardpom.xml文件1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;spring-cloud-parent&lt;/artifactId&gt; &lt;groupId&gt;cn.peach&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../spring-cloud-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;hystrix-dashboard&lt;/artifactId&gt; &lt;name&gt;hystrix-dashboard&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ProductServiceHystrixDashboardApplication.java断路器监控启动类，主要就是@EnableHystrixDashboard 1234567891011121314151617181920package cn.peach;import cn.hutool.core.util.NetUtil;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.cloud.netflix.hystrix.dashboard.EnableHystrixDashboard;@SpringBootApplication@EnableHystrixDashboardpublic class ProductServiceHystrixDashboardApplication&#123; public static void main(String[] args) &#123; int port = 8020; if(!NetUtil.isUsableLocalPort(port)) &#123; System.err.printf(&quot;端口%d被占用了，无法启动%n&quot;, port ); System.exit(1); &#125; new SpringApplicationBuilder(ProductServiceHystrixDashboardApplication.class).properties(&quot;server.port=&quot; + port).run(args); &#125;&#125; application.yml:123spring: application: name: hystrix-dashboard ProductViewServiceFeignApplication.java 修改视图微服务项目，以使得它可以把信息共享给监控中心。 修改ProductViewServiceFeignApplication， 增加 @EnableCircuitBreaker 1234567891011121314151617181920212223242526272829303132333435package cn.peach;import brave.sampler.Sampler;import cn.hutool.core.util.NetUtil;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.circuitbreaker.EnableCircuitBreaker;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.openfeign.EnableFeignClients;import org.springframework.context.annotation.Bean;@SpringBootApplication@EnableEurekaClient@EnableDiscoveryClient@EnableFeignClients@EnableCircuitBreaker //把信息共享给监控中心public class ProductViewServiceFeignApplication &#123; public static void main(String[] args) &#123; // 判断 rabiitMQ 是否启动 int rabbitMQPort = 5672; if(NetUtil.isUsableLocalPort(rabbitMQPort)) &#123; System.err.printf(&quot;未在端口%d 发现 rabbitMQ服务，请检查rabbitMQ 是否启动&quot;, rabbitMQPort ); System.exit(1); &#125; // 推荐 8012 、 8013 或者 8014 SpringApplication.run(ProductViewServiceFeignApplication.class, args); &#125; @Bean public Sampler defaultSampler() &#123; return Sampler.ALWAYS_SAMPLE; &#125;&#125; AccessViewService.java:准备一个不停访问服务的类： AccessViewService。 这样可以不断地访问服务，才便于在监控那里观察现象。 1234567891011121314151617181920212223242526package cn.peach.util;import cn.hutool.core.thread.ThreadUtil;import cn.hutool.http.HttpUtil;public class AccessViewService &#123; public static void main(String[] args) &#123; while(true) &#123; ThreadUtil.sleep(1000); access(8012); access(8013); &#125; &#125; public static void access(int port) &#123; try &#123; String html= HttpUtil.get(String.format(&quot;http://127.0.0.1:%d/products&quot;,port)); System.out.printf(&quot;%d 地址的视图服务访问成功，返回大小是 %d%n&quot; ,port, html.length()); &#125; catch(Exception e) &#123; System.err.printf(&quot;%d 地址的视图服务无法访问%n&quot;,port); &#125; &#125;&#125; 启动： 首先挨个运行 EurekaServerApplication, ConfigServerApplication, ProductDataServiceApplication， ProductViewServiceFeignApplication，ProductServiceHystrixDashboardApplication; 运行视图微服务里的 AccessViewService 来周期性地访问 http://127.0.0.1:8012/products 。 因为只有访问了，监控里才能看到数据; 打开监控地址 http://localhost:8020/hystrix; 如图所示，在最上面输入http://localhost:8012/actuator/hystrix.stream : 点击 Monitor Stream 就可以看到监控信息了。","tags":[],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"},{"name":"SpringCloud","slug":"Cloud/SpringCloud","permalink":"http://example.com/categories/Cloud/SpringCloud/"}]},{"title":"SpringCloud系列10-断路器Hystrix","date":"2022-05-13T08:30:00.676Z","path":"blog/Cloud/SpringCloud/SpringCloud系列10-断路器Hystrix/","text":"问题:视图微服务是依赖于数据微服务的。那么当数据微服务不可用的时候，会怎么样呢？我们主动把 ProductDataServiceApplication 关闭，然后再访问：http://localhost:8012/products 就会抛出异常。客户也看不懂这个是什么。为了解决这个问题，我们就会引入断路器的概念。 断路器:断路器: 就是当被访问的微服务无法使用的时候，当前服务能够感知这个现象，并且提供一个备用的方案出来。 改造:pom.xml:增加 jar spring-cloud-starter-netflix-hystrix 以支持断路器。 12345&lt;!--增加 jar spring-cloud-starter-netflix-hystrix 以支持断路器--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; ProductClientFeign.java注解由原来的 @FeignClient(value = &quot;PRODUCT-DATA-SERVICE&quot;)修改为 @FeignClient(value = &quot;PRODUCT-DATA-SERVICE&quot;,fallback = ProductClientFeignHystrix.class)。 123456789101112131415package cn.peach.client;import cn.peach.pojo.Product;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import java.util.List;@FeignClient(value = &quot;PRODUCT-DATA-SERVICE&quot;,fallback = ProductClientFeignHystrix.class)public interface ProductClientFeign &#123; @GetMapping(&quot;/products&quot;) public List&lt;Product&gt; listProdcuts();&#125; ProductClientFeignHystrix.javaProductClientFeignHystrix 实现了 ProductClientFeign 接口，并提供了 listProdcuts() 方法。这个方法就会固定返回包含一条信息的集合。 1234567891011121314151617181920package cn.peach.client;/* * Create By Tao on 2022/4/24. * * */import cn.peach.pojo.Product;import org.springframework.stereotype.Component;import java.util.ArrayList;import java.util.List;@Componentpublic class ProductClientFeignHystrix implements ProductClientFeign&#123; public List&lt;Product&gt; listProdcuts()&#123; List&lt;Product&gt; result = new ArrayList&lt;&gt;(); result.add(new Product(0,&quot;产品数据微服务现在不可用&quot;,0)); return result; &#125;&#125; application.yml在配置文件里开启断路器: 1feign.hystrix.enabled: true 启动:挨个启动： EurekaServerApplication, ConfigServerApplication, ProductViewServiceFeignApplication。注意: 数据服务是没有启动的。然后访问地址：http://127.0.0.1:8012/products会发现，依然可以打开，并且得到提示信息： 产品数据微服务不可用。","tags":[],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"},{"name":"SpringCloud","slug":"Cloud/SpringCloud","permalink":"http://example.com/categories/Cloud/SpringCloud/"}]},{"title":"SpringCloud系列9-消息总线Bus","date":"2022-05-13T08:29:27.444Z","path":"blog/Cloud/SpringCloud/SpringCloud系列9-消息总线Bus/","text":"问题：虽然配置了config-server, 也把视图服务改造成了配置客户端，但是当需要刷新配置信息的时候，不得不既重启 config-server, 又重启微服务。 这样的体验当然是不太好的。 我们当然是希望一旦 git 上的配置信息修改之后，就可以自动地刷新到微服务里，而不是需要手动重启才可以。 RabbitMQ： springCloud 通过 rabbitMQ 来进行消息广播，以达到有配置信息发生改变的时候，广播给多个微服务的效果。 需要先安装 rabbitMQ 服务器。 改造:pom.xml:product-view-service-feign: 新增spring-boot-starter-actuator 用于访问路径：&#x2F;actuator&#x2F;bus-refresh 新增spring-cloud-starter-bus-amqp 用于支持 rabbitmq 12345678910&lt;!--多了spring-boot-starter-actuator 用于访问路径：/actuator/bus-refresh--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--多了spring-cloud-starter-bus-amqp 用于支持 rabbitmq--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;/artifactId&gt;&lt;/dependency&gt; bootstrap.yml:新增 but总线配置: 123456spring: cloud: bus: enabled: true trace: enabled: true 新增 rabbitMQ 配置: 12345rabbitmq: host: localhost port: 5672 username: guest password: guest 完整代码： 123456789101112131415161718192021spring: cloud: config: label: develop profile: dev discovery: enabled: true serviceId: config-server bus: enabled: true trace: enabled: true client: serviceUrl: defaultZone: http://localhost:8761/eureka/rabbitmq: host: localhost port: 5672 username: guest password: guest application.yml:新增路径访问允许,这样才能访问 &#x2F;actuator&#x2F;bus-refresh: 12345678management: endpoints: web: exposure: include: &quot;*&quot; cors: allowed-origins: &quot;*&quot; allowed-methods: &quot;*&quot; FreshConfigUtil.java使用 post 的方式访问 http://localhost:8012/actuator/bus-refresh 地址，之所以要专门做一个 FreshConfigUtil 类，就是为了可以使用 post 访问，因为它不支持 get 方式访问，直接把这个地址放在浏览器里，是会抛出 405错误的。 12345678910111213141516171819202122package cn.peach.util;/* * Create By Tao on 2022/4/24. * * */import cn.hutool.http.HttpUtil;import java.util.HashMap;public class FreshConfigUtil &#123; public static void main(String[] args) &#123; HashMap&lt;String,String&gt; headers =new HashMap&lt;&gt;(); headers.put(&quot;Content-Type&quot;, &quot;application/json; charset=utf-8&quot;); System.out.println(&quot;因为要去git获取，还要刷新config-server, 会比较卡，所以一般会要好几秒才能完成，请耐心等待&quot;); String result = HttpUtil.createPost(&quot;http://localhost:8012/actuator/bus-refresh&quot;).addHeaders(headers).execute().body(); System.out.println(&quot;result:&quot;+result); System.out.println(&quot;refresh 完成&quot;); &#125;&#125; 对服务链路追踪的影响因为视图服务进行了改造，支持了 rabbitMQ, 那么在默认情况下，它的信息就不会进入 Zipkin了。 在Zipkin 里看不到视图服务的资料了。为了解决这个问题，在启动 Zipkin 的时候 带一个参数就好了：–zipkin.collector.rabbitmq.addresses&#x3D;localhost即改成了： 1java -jar zipkin-server-2.10.1-exec.jar --zipkin.collector.rabbitmq.addresses=localhost 注： 重启 zipkin 后，要再访问业务地址才可以看到依赖关系。","tags":[],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"},{"name":"SpringCloud","slug":"Cloud/SpringCloud","permalink":"http://example.com/categories/Cloud/SpringCloud/"}]},{"title":"SpringCloud系列8-配置客户端","date":"2022-05-13T08:29:10.862Z","path":"blog/Cloud/SpringCloud/SpringCloud系列8-配置客户端/","text":"配置客户端把现成的 视图微服务-Feign 改造成配置客户端，使得其可以从配置服务器上获取版本信息。 pom.xml增加一个 spring-cloud-starter-config 用于访问配置服务器。 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;&lt;/dependency&gt; bootstrap.yml 作为配置客户端，它需要在 bootstrap.yml 里配置 config-server 的信息，而不是像以前那样在 application.yml 里进行配置。 bootstrap.yml 和 application.yml 的区别，简单说就是前者先启动，并且一些系统方面的配置需要在 bootstrap.yml 里进行配置。 在 bootstrap.yml 里配置提供了 serviceId: config-server, 这个是配置服务器在 eureka server 里的服务名称，这样就可以定位 config-server了。123456789101112131415spring: cloud: config: label: develop profile: dev discovery: enabled: true serviceId: config-server bus: enabled: true trace: enabled: true client: serviceUrl: defaultZone: http://localhost:8761/eureka/ application.yml把 eureka 地址信息移动到了 bootstrap.yml 里。 123456789101112spring: application: name: product-view-service-feign thymeleaf: cache: false prefix: classpath:/templates/ suffix: .html encoding: UTF-8 content-type: text/html mode: HTML5 zipkin: base-url: http://localhost:9411 ProductController.java增加这个属性，就可以从 config-server 去获取 version 信息了。 12@Value(&quot;$&#123;version&#125;&quot;)String version; 然后把这个信息放在 Model里 1m.addAttribute(&quot;version&quot;, version); 完整代码： 12345678910111213141516@Controller@RefreshScopepublic class ProductController &#123; @Autowired ProductService productService; @Value(&quot;$&#123;version&#125;&quot;) String version; @RequestMapping(&quot;/products&quot;) public Object products(Model m) &#123; List&lt;Product&gt; ps = productService.listProducts(); m.addAttribute(&quot;version&quot;, version); m.addAttribute(&quot;ps&quot;, ps); return &quot;products&quot;; &#125;&#125; products.html:12345&lt;tr&gt; &lt;td align=&quot;center&quot; colspan=&quot;3&quot;&gt; &lt;p th:text=&quot;$&#123;version&#125;&quot; &gt;how2j springcloud version unknown&lt;/p&gt; &lt;/td&gt;&lt;/tr&gt; 启动:挨个启动 EurekaServerApplication, ConfigServerApplication, ProductDataServiceApplication, ProductViewServiceFeignApplication, 然后访问如下地址：http://localhost:8012/products","tags":[],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"},{"name":"SpringCloud","slug":"Cloud/SpringCloud","permalink":"http://example.com/categories/Cloud/SpringCloud/"}]},{"title":"SpringCloud系列7-配置服务器","date":"2022-05-13T08:28:55.334Z","path":"blog/Cloud/SpringCloud/SpringCloud系列7-配置服务器/","text":"配置服务的需要:有时候，微服务要做集群，这就意味着，会有多个微服务实例。 在业务上有时候需要修改一些配置信息，比如说 版本信息吧~ 倘若没有配置服务， 那么就需要挨个修改微服务，挨个重新部署微服务，这样就比较麻烦。为了偷懒， 这些配置信息就会放在一个公共的地方，比如git, 然后通过配置服务器把它获取下来，然后微服务再从配置服务器上取下来。这样只要修改git上的信息，那么同一个集群里的所有微服务都立即获取相应信息了，这样就大大节约了开发，上线和重新部署的时间了。 如图所示，我们先在 git 里保存 version 信息， 然后通过 ConfigServer 去获取 version 信息， 接着不同的视图微服务实例再去 ConfigServer 里获取 version. git首先要准备git。如下是已经准备好的 git:https://github.com/taoliu-hub/spring-cloud-angular11/blob/develop/respo/product-view-service-feign-dev.properties这里就准备了版本信息： version &#x3D; Version 1.1 创建子项目: config-serverpom.xml主要是 spring-cloud-config-server 这个 jar 包 1234567891011121314151617181920212223242526272829303132&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;spring-cloud-parent&lt;/artifactId&gt; &lt;groupId&gt;cn.peach&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../spring-cloud-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;cn.peach&lt;/groupId&gt; &lt;artifactId&gt;config-server&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;config-server&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 启动类：ConfigServerApplication123456789101112131415161718package cn.peach;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.config.server.EnableConfigServer;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableConfigServer@EnableDiscoveryClient@EnableEurekaClientpublic class ConfigServerApplication &#123; public static void main(String[] args) &#123; // 推荐 8030 SpringApplication.run(ConfigServerApplication.class, args); &#125;&#125; application.yml12345678910111213141516171819spring: application: name: config-server cloud: config: label: develop name: product-view-service-feign profile: dev server: git: uri: https://github.com/taoliu-hub/spring-cloud-angular11.git searchPaths: respo default-label: main timeout: 500000eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 启动先启动 EurekaServerApplication， 再启动 ConfigServerApplication， 然后访问http://localhost:8030/version/dev","tags":[],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"},{"name":"SpringCloud","slug":"Cloud/SpringCloud","permalink":"http://example.com/categories/Cloud/SpringCloud/"}]},{"title":"SpringCloud系列6-服务链路追踪","date":"2022-05-13T08:28:36.128Z","path":"blog/Cloud/SpringCloud/SpringCloud系列6-服务链路追踪/","text":"什么是服务链路我们有两个微服务，分别是数据服务和视图服务，随着业务的增加，就会有越来越多的微服务存在，他们之间也会有更加复杂的调用关系。这个调用关系，仅仅通过观察代码，会越来越难以识别，所以就需要通过 zipkin 服务链路追踪服务器 这个东西来用图片进行识别了 改造 eureka-server 不需要做改造; product-data-service和product-view-service 需要进行改造以使其可以被追踪到。 pom.xml都加上以下依赖：12345&lt;!--服务链路追踪--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-zipkin&lt;/artifactId&gt;&lt;/dependency&gt; application.yml都加上以下配置信息：123spring: zipkin: base-url: http://localhost:9411 启动类都加上以下配置信息：ProductDataServiceApplication.java 和 ProductViewServiceFeignApplication.java： 1234@Beanpublic Sampler defaultSampler() &#123; return Sampler.ALWAYS_SAMPLE;&#125; 启动测试： 需要启动链路追踪服务器：zipkin-server-2.10.1-exec.jar, 命令启动:1java -jar zipkin-server-2.10.1-exec.jar 启动 eureka-server, 改造后的 product-data-service 和 product-view-service-feign; 访问一次 http://127.0.0.1:8012/products 通过 视图微服务去访问数据微服务，这样链路追踪服务器才知道有这事儿发生 然后打开链路追踪服务器 http://localhost:9411/zipkin/dependency/ 就可以看到如图所示的 视图微服务调用数据微服务 的图形了","tags":[],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"},{"name":"SpringCloud","slug":"Cloud/SpringCloud","permalink":"http://example.com/categories/Cloud/SpringCloud/"}]},{"title":"SpringCloud系列5-视图微服务-Feign","date":"2022-05-13T08:27:20.499Z","path":"blog/Cloud/SpringCloud/SpringCloud系列5-视图微服务-Feign/","text":"Feign 概念:是对Ribbon的封装，调用起来更简单。 代码片段的区别 Ribbon方式：123456@AutowiredRestTemplate restTemplate;public List&lt;Product&gt; listProdcuts() &#123; return restTemplate.getForObject(&quot;http://PRODUCT-DATA-SERVICE/products&quot;,List.class);&#125; Feign方式：123456@FeignClient(value = &quot;PRODUCT-DATA-SERVICE&quot;)public interface ProductClientFeign &#123; @GetMapping(&quot;/products&quot;) public List&lt;Product&gt; listProdcuts();&#125; 创建子项目 product-view-service-feignpom.xml:123456789101112131415161718192021222324252627282930313233&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;spring-cloud-parent&lt;/artifactId&gt; &lt;groupId&gt;cn.peach&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../spring-cloud-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;product-view-service-feign&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; Feign 客户端:Feign 客户端， 通过 注解方式 访问 访问PRODUCT-DATA-SERVICE服务的 products路径， product-data-service 既不是域名也不是ip地址，而是 数据服务在 eureka 注册中心的名称。 注意: 这里只是指定了要访问的 微服务名称，但是并没有指定端口号到底是 8001, 还是 8002. Feign方式：1234567891011121314package cn.peach.client;import cn.peach.pojo.Product;import org.springframework.cloud.openfeign.FeignClient;import org.springframework.web.bind.annotation.GetMapping;import java.util.List;@FeignClient(value = &quot;PRODUCT-DATA-SERVICE&quot;)public interface ProductClientFeign &#123; @GetMapping(&quot;/products&quot;) public List&lt;Product&gt; listProdcuts();&#125; Java code: 注意：这里忽略controller、 service、 repository, html层的代码，只列出重要部分代码，如需了解详情可参阅以下地址获取代码：https://github.com/taoliu-hub/spring-cloud-angular11/tree/main/spring-cloud. 服务类: ProductServiceImpl 123456789101112131415161718192021package cn.peach.service.impl;import cn.peach.client.ProductClientFeign;import cn.peach.pojo.Product;import cn.peach.service.ProductService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class ProductServiceImpl implements ProductService &#123; @Autowired ProductClientFeign productClientFeign; @Override public List&lt;Product&gt; listProducts() &#123; return productClientFeign.listProdcuts(); &#125;&#125; 启动类，注解多了个 @EnableFeignClients， 表示用于使用 Feign 方式。 1234567891011121314151617181920package cn.peach;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.cloud.openfeign.EnableFeignClients;@SpringBootApplication@EnableEurekaClient@EnableDiscoveryClient@EnableFeignClientspublic class ProductViewServiceFeignApplication &#123; public static void main(String[] args) &#123; // 推荐 8012 、 8013 或者 8014 SpringApplication.run(ProductViewServiceFeignApplication.class, args); &#125;&#125; 配置application.yml配置类，指定了 eureka server 的地址，以及自己的名称。 另外是一些 thymeleaf 的默认配置。 1234567891011121314eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/spring: application: name: product-view-service-feign thymeleaf: cache: false prefix: classpath:/templates/ suffix: .html encoding: UTF-8 content-type: text/html mode: HTML5 启动并访问注册中心Eureka:刷新访问：http://127.0.0.1:8761/。 启动并访问视图微服务product-view-service-feign:刷新访问：http://127.0.0.1:8012/products。 调用图：如图所示： 首先数据微服务和视图微服务都被 eureka 管理起来了。 数据服务是由两个实例的集群组成的，端口分别是 8001 ， 8002 视图微服务通过 注册中心调用微服务， 然后负载均衡到 8001 或者 8002 端口的应用上。","tags":[],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"},{"name":"SpringCloud","slug":"Cloud/SpringCloud","permalink":"http://example.com/categories/Cloud/SpringCloud/"}]},{"title":"SpringCloud系列4-视图微服务-RIBBON","date":"2022-05-13T08:25:21.444Z","path":"blog/Cloud/SpringCloud/SpringCloud系列4-视图微服务-RIBBON/","text":"Ribbon 概念访问前面注册好的数据微服务, springcloud 提供了两种方式: Ribbon: 是使用 restTemplate 进行调用，并进行客户端负载均衡。 Feign: 是对 Ribbon的封装，调用起来更简单。 什么是客户端负载均衡:在前面注册数据微服务里，注册了8001和8002两个微服务， Ribbon会从注册中心获知这个信息，然后由 Ribbon 这个客户端自己决定是调用哪个，这个就叫做客户端负载均衡。 创建子项目: product-view-service-ribbonpom.xml包含以下jar: spring-cloud-starter-netflix-eureka-client: eureka 客户端 spring-boot-starter-web： springmvc spring-boot-starter-thymeleaf： thymeleaf 做服务端渲染，(前后端分离项目不用配置)。 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;spring-cloud-parent&lt;/artifactId&gt; &lt;groupId&gt;cn.peach&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../spring-cloud-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;product-view-service-ribbon&lt;/artifactId&gt; &lt;name&gt;product-view-service-ribbon&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; Ribbon 客户端Ribbon客户端: 通过restTemplate 访问 http://PRODUCT-DATA-SERVICE/products,而 product-data-service既不是域名也不是ip地址，而是数据服务在eureka 注册中心的名称. 注意: 这里只是指定了要访问的 微服务名称，但是并没有指定端口号到底是8001, 还是8002. 12345678910111213141516171819package cn.peach.client;import cn.peach.pojo.Product;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;import org.springframework.web.client.RestTemplate;import java.util.List;@Componentpublic class ProductClientRibbon &#123; @Autowired RestTemplate restTemplate; public List&lt;Product&gt; listProdcuts() &#123; return restTemplate.getForObject(&quot;http://PRODUCT-DATA-SERVICE/products&quot;,List.class); &#125;&#125; Java code: 注意：这里忽略controller、 service、 repository, html层的代码，只列出重要部分代码，如需了解详情可参阅以下地址获取代码：https://github.com/taoliu-hub/spring-cloud-angular11/tree/main/spring-cloud. 服务类: ProductServiceImpl 12345678910111213141516171819202122package cn.peach.service.impl;import cn.peach.client.ProductClientRibbon;import cn.peach.pojo.Product;import cn.peach.service.ProductService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;import java.util.List;@Servicepublic class ProductServiceImpl implements ProductService &#123; @Autowired ProductClientRibbon productClientRibbon; @Override public List&lt;Product&gt; listProducts() &#123; return productClientRibbon.listProdcuts(); &#125;&#125; 启动类，注解多了个 @EnableDiscoveryClient，表示用于发现eureka 注册中心的微服务, 启动类，多了个 RestTemplate，就表示用 restTemplate 这个工具来做负载均衡, 考虑到要做集群。 自己输入端口，推荐 80010，8002，8003. 1234567891011121314151617181920212223import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;import org.springframework.context.annotation.Bean;import org.springframework.cloud.client.loadbalancer.LoadBalanced;import org.springframework.web.client.RestTemplate;@SpringBootApplication@EnableEurekaClient@EnableDiscoveryClientpublic class ProductViewServiceRibbonApplication &#123; public static void main( String[] args ) &#123; SpringApplication.run(ProductDataServiceApplication.class, args); &#125; @Bean @LoadBalanced RestTemplate restTemplate() &#123; return new RestTemplate(); &#125;&#125; 配置application.yml配置类，指定了 eureka server 的地址，以及自己的名称。 另外是一些 thymeleaf 的默认配置。 1234567891011121314eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/spring: application: name: product-view-service-ribbon thymeleaf: cache: false prefix: classpath:/templates/ suffix: .html encoding: UTF-8 content-type: text/html mode: HTML5 启动并访问注册中心Eureka:刷新访问：http://127.0.0.1:8761/。 启动并访问视图微服务product-view-service-ribbon:刷新访问：http://127.0.0.1:8010/products。 调用图：如图所示： 首先数据微服务和视图微服务都被 eureka 管理起来了。 数据服务是由两个实例的集群组成的，端口分别是 8001 ， 8002 视图微服务通过 注册中心调用微服务， 然后负载均衡到 8001 或者 8002 端口的应用上。","tags":[],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"},{"name":"SpringCloud","slug":"Cloud/SpringCloud","permalink":"http://example.com/categories/Cloud/SpringCloud/"}]},{"title":"SpringCloud系列3-注册数据微服务","date":"2022-05-13T08:24:23.455Z","path":"blog/Cloud/SpringCloud/SpringCloud系列3-注册数据微服务/","text":"创建子项目: product-data-service注意：若前面父子(聚合)项目创建了数据微服务，可直接更新此微服务。修改 pom.xml 为如下： spring-cloud-starter-netflix-eureka-client 表示这是个 eureka 客户端。 spring-boot-starter-web: 表示这是个web服务，会提供控制层1234567891011121314151617181920212223242526&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;spring-cloud-parent&lt;/artifactId&gt; &lt;groupId&gt;cn.peach&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../spring-cloud-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;product-data-service&lt;/artifactId&gt; &lt;name&gt;product-data-service&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 启动类ProductDataServiceApplication 启动类， 考虑到要做集群。 自己输入端口，推荐 8001，8002，8003. 注意：这里忽略controller、 service、 repository, html层的代码，只列出重要部分代码，如需了解详情可参阅以下地址获取代码：https://github.com/taoliu-hub/spring-cloud-angular11/tree/main/spring-cloud. 123456789101112131415package cn.peach;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@SpringBootApplication@EnableEurekaClientpublic class ProductDataServiceApplication&#123; public static void main( String[] args ) &#123; SpringApplication.run(ProductDataServiceApplication.class, args); &#125;&#125; 配置application.yml 设置微服务的名称： product-data-service 设置注册中心的地址： http://localhost:8761/eureka/, 与eureka-server中的配置 application.yml一致。 12345678910# server:# port: 因为会启动多个 product-data-service, 所以端口号由用户自动设置，推荐 8001,8002,8003 spring: application: name: product-data-serviceeureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 启动并访问注册中心Eureka:刷新访问：http://127.0.0.1:8761/。 补充(上图红色信息)： EMERGENCY! EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT. RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEING EXPIRED JUST TO BE SAFE. 上面这句话意思是，Eureka可能会声明已经不存在的实例。刷新数小于阈值时，为了安全起见不会剔除过期实例。 Eureka的默认阈值为：85% 比如目前有10个微服务，只有8个有心跳反应时，（8&#x2F;10&#x3D;80%&lt;85%）Eureka就会开启保护机制，过期的实例不会立马剔除。并且出这个紧急警告，在搭建Eureka Server时，比如我们搭建了2个Eureka Server，并且禁止自注册，Eureka Server自身算一个服务，那么其中任意一个Eureka，只能获得一个心跳，1&#x2F;2&#x3D;50%。那么也会出现这个警告。 当不想有这个红色警告是，本机自测可以关闭Eureka保护配置。生产环境下不要关。在application.yml文件中配置：12server: enable-self-preservation: false","tags":[],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"},{"name":"SpringCloud","slug":"Cloud/SpringCloud","permalink":"http://example.com/categories/Cloud/SpringCloud/"}]},{"title":"SpringCloud系列2-服务注册中心","date":"2022-05-13T08:23:20.668Z","path":"blog/Cloud/SpringCloud/SpringCloud系列2-服务注册中心/","text":"创建子项目: eureka-serverpom.xml ，增加 spring-cloud-starter-netflix-eureka-server jar 包 12345678910111213141516171819202122&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;spring-cloud-parent&lt;/artifactId&gt; &lt;groupId&gt;cn.peach&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../spring-cloud-parent/pom.xml&lt;/relativePath&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;eureka-server&lt;/artifactId&gt; &lt;name&gt;eureka-server&lt;/name&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 启动类: EurekaServerApplication EurekaServer，它扮演的角色是注册中心，用于注册各种微服务，以便于其他微服务找到和访问。 EurekaServer 本身就是个 Springboot 微服务, 所以它有 @SpringBootApplication 注解。 @EnableEurekaServer 表示这是个 EurekaServer 。完整代码：123456789101112131415161718192021package cn.peach;import cn.hutool.core.util.NetUtil;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.boot.builder.SpringApplicationBuilder;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@SpringBootApplication@EnableEurekaServerpublic class EurekaServerApplication&#123; public static void main(String[] args) &#123; //8761 这个端口是默认的，就不要修改了，后面的子项目，都会访问这个端口。 int port = 8761; if(!NetUtil.isUsableLocalPort(port)) &#123; System.err.printf(&quot;端口%d被占用了，无法启动%n&quot;, port ); System.exit(1); &#125; new SpringApplicationBuilder(EurekaServerApplication.class).properties(&quot;server.port=&quot; + port).run(args); &#125;&#125; 配置application.yml 设置微服务的名称： eureka-server hostname: localhost 表示主机名称。 registerWithEureka：false. 表示是否注册到服务器。 因为它本身就是服务器，所以就无需把自己注册到服务器了。 fetchRegistry: false. 表示是否获取服务器的注册信息，和上面同理，这里也设置为 false。 defaultZone： http:&#x2F;&#x2F;${eureka.instance.hostname}:${server.port}&#x2F;eureka&#x2F; 自己作为服务器，公布出来的地址。 比如后续某个微服务要把自己注册到 eureka server, 那么就要使用这个地址： http://localhost:8761/eureka/ 123456789101112eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ spring: application: name: eureka-server 启动并访问注册中心Eureka:运行 EurekaServerApplication，并访问：http://127.0.0.1:8761/，默认端口号为：8761。","tags":[],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"},{"name":"SpringCloud","slug":"Cloud/SpringCloud","permalink":"http://example.com/categories/Cloud/SpringCloud/"}]},{"title":"SpringCloud系列1-父子(聚合)项目","date":"2022-05-13T06:05:45.854Z","path":"blog/Cloud/SpringCloud/SpringCloud系列1-父子(聚合)项目/","text":"SpringCloud代码结构 创建父项目: spring-cloud-parent修改pom： 1&lt;packaging&gt;pom&lt;/packaging&gt; 注意： 父项目只有pom.xml文件， packaging值为pom. 完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.6.RELEASE&lt;/version&gt; &lt;!-- 踩坑:版本不对会导致Feign连接不上，亲测其它版本, 2.3.3.RELEASE version. --&gt; &lt;relativePath/&gt; &lt;/parent&gt; &lt;groupId&gt;cn.peach&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-parent&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;spring-cloud-parent&lt;/name&gt; &lt;description&gt;spring-cloud-parent project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-cloud.version&gt;Finchley.SR2&lt;/spring-cloud.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;$&#123;spring-cloud.version&#125;&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt;&lt;/project&gt; 创建子项目: product-data-service修改pom： 123456789&lt;parent&gt; &lt;artifactId&gt;spring-cloud-parent&lt;/artifactId&gt; &lt;groupId&gt;cn.peach&lt;/groupId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;relativePath&gt;../spring-cloud-parent/pom.xml&lt;/relativePath&gt;&lt;/parent&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;&lt;artifactId&gt;product-data-service&lt;/artifactId&gt;&lt;name&gt;product-data-service&lt;/name&gt;","tags":[],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"},{"name":"SpringCloud","slug":"Cloud/SpringCloud","permalink":"http://example.com/categories/Cloud/SpringCloud/"}]},{"title":"SpringCloud介绍","date":"2022-05-12T10:23:36.531Z","path":"blog/Cloud/SpringCloud/SpringCloud/","text":"基础知识介绍：单体架构系统：单体架构就是所有功能，都放在一个应用里。 好处：便于开发，测试，部署也很方便，直接打成一个 jar 或者 war, 就什么都好了。 弊端：要体现在高访问，高并发的上限是固定的。 比如一个单体架构，能够承受 1000次访问&#x2F;秒。 但是访问量达到 2000次&#x2F;秒的时候，就会非常卡顿，严重影响业务，并且仅仅依靠单体架构本身，很难突破这个瓶颈了。 集群和分布式：既然单体架构会有性能上的瓶颈，那么总要解决呀。 解决办法通常就是采用集群和分布式来做。 集群：指一组相互独立的计算机，通过高速的网络组成一个计算机系统。服务器集群就是指将很多服务器集中起来一起进行同一种服务，在客户端看来就像是只有一个服务器。 集群的特点和优势: 高性能 性价比 可伸缩性集群的分类 负载均衡集群（Load balancing clusters）简称LBC 高可用性集群（High-availability clusters）简称HAC 高性能计算集群（High-perfomance clusters）简称HPC 分布式：指将不同的业务分布在不同的地方，而集群指的是将几台服务器集中在一起，实现同一业务。分布式中的每一个节点，都可以做集群，而集群并不一定就是分布式的。 分布式一致性：分布式系统中，一个问题是负载均衡，另外一个问题就是数据的一致性。 在分布式集群中，很难保障数据的一致性。在以往的单节点服务中，通常使用锁来实现，当发生并发冲突时 通过对锁的持有获得对象的操作权，从而保证数据在同一时刻只允许被一个请求操作。但是在集群中，若同样采用锁的机制，那么需要一台节点用来管理分配锁，当其他节点进行请求前，首先去获取锁从而获得执行权。但是这样会产生单节点问题，即若管理锁的节点down掉，那么整个集群将无法工作。同时，由于锁的机制会使整个集群变成串行化单节点的形式，失去了集群的意义。 分布式和集群的关系： 根据分布式的介绍看出，其主要的功能是用了将我们的系统模块化，将系统进行解耦的，方便我们的维护和开发的，但是其并不能解决我们的并发问题，也无法保证我们的系统在服务器宕机后的正常运转。 集群就恰好弥补了分布式的缺陷，集群就是多个服务器处理相同的业务，这在一方面可以解决或者说改善我们系统的并发问题，一方面可以解决我们服务器如果出现一定数量的宕机后，系统仍然可以正常运转。 SpringCloud介绍：SpringCloud 就是一套工具。 Spring Cloud 并不是一个项目，而是一组项目的集合。包含了很多的子项目，每一个子项目都是一种微服务开发过程中遇到的问题的一种解决方案。它利用 Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot的开发风格做到一键启动和部署。Spring Cloud并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。 子项目介绍: Spring Cloud Config：集中配置管理工具，分布式系统中统一的外部配置管理，可以支持客户端配置的刷新及加密、解密操作, 可以让你把配置放到远程服务器，目前支持本地存储、Git 以及 Subversion。 Spring Cloud Netflix：针对多种 Netflix 组件提供的开发工具包，其中包括 Eureka、Hystrix、Ribbon、Feign、Zuul、Archaius 等组件, 如下: Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制； Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力； Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略； Feign：基于Ribbon和Hystrix的声明式服务调用组件； Zuul：API网关组件，对请求提供路由及过滤功能； Archaius：基于java的配置管理类库，主要用于多配置存储的动态获取。 Spring Cloud Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与 Spring Cloud Config 联合实现热部署。 Spring Cloud Consul：封装了 Consul 操作，consul 是一个服务发现与配置工具，与 Docker 容器可以无缝集成。 Spring Cloud Security ：安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。 Spring Cloud Sleuth：日志收集工具包，封装了 Dapper，Zipkin 和 HTrace 操作. Spring Cloud 应用的分布式跟踪实现。 Spring Cloud Stream：数据流操作开发包，封装了与 Redis，Rabbit、Kafka 等发送接收消息，实现的消息微服务。 Spring Cloud Task：用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。 Spring Cloud Zookeeper：基于 ZooKeeper 的服务发现与配置管理组件。 Spring Cloud Gateway：API网关组件，对请求提供路由及过滤功能, Spring Cloud 网关相关的整合实现。 Spring Cloud Aws：用于简化整合 Amazon Web Service 的组件。 Spring Cloud Cli：基于 Spring Boot CLI，可以让你以命令行方式快速建立云组件。 Spring Cloud Commons：服务发现、负载均衡、熔断机制这种模式为 Spring Cloud 客户端提供了一个通用的抽象层。 Spring Cloud Contract：Spring Cloud Contract是一个总体项目，其中包含帮助用户成功实施消费者驱动合同方法的解决方案(契约测试)。 Spring Cloud Cloudfoundry：通过 Oauth2 协议绑定服务到 CloudFoundry，CloudFoundry 是 VMware 推出的开源 PaaS 云平台。 Spring Cloud OpenFeign：基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。","tags":[],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"},{"name":"SpringCloud","slug":"Cloud/SpringCloud","permalink":"http://example.com/categories/Cloud/SpringCloud/"}]},{"title":"JAVA数据结构和算法","date":"2022-05-12T09:35:21.866Z","path":"blog/数据结构和算法/JAVA数据结构和算法/","text":"JAVA数据结构和算法： 数据结构分类：线性结构和非线性结构： 问题一：什么是线性和非线性； 个人的理解是：数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构；线性结构包括：数组，链表，队列，栈；非线性结构包括：树，图，表； 详解：一.线性结构 1.数组特点：我们都知道数组中的元素在内存中连续存储的，可以根据是下标快速访问元素，因此，查询速度很快，然而插入和删除时，需要对元素移动空间，比较慢。数组使用场景：频繁查询，很少增加和删除的情况。 2.链表特点：元素可以不连续内存中，是以索引将数据联系起来的，当查询元素的时候需要从头开始查询，所以效率比较低，然而添加和删除的只需要修改索引就可以了链表使用场景：少查询，需要频繁的插入或删除情况 3.队列特点：先进先出，队列使用场景：多线程阻塞队列管理非常有用 4.栈特点：先进后出，就像一个箱子，栈使用场景：实现递归以及表示式 5.数组与链表的区别数组连续，链表不连续（从数据存储形式来说）数组内存静态分配，链表动态分配数组查询复杂度O(1)，链表查询复杂度O(n)数组添加或删除，复杂度O(n),链表添加删除，复杂度O(1)数组从栈中分配内存。链表从堆中分配内存。 补充：时间复杂度O(1), O(n), O(logn), O(nlogn)指什么 描述算法复杂度时,常用o(1), o(n), o(logn), o(nlogn)表示对应算法的时间复杂度，是算法的时空复杂度的表示。不仅仅用于表示时间复杂度，也用于表示空间复杂度。O后面的括号中有一个函数，指明某个算法的耗时&#x2F;耗空间与数据增长量之间的关系。其中的n代表输入数据的量。 O(1)： 是最低的时空复杂度了，代表耗时&#x2F;耗空间与输入数据大小无关，无论输入数据增大多少倍，耗时&#x2F;耗空间都不变。 哈希算法就是典型的O(1)时间复杂度，无论数据规模多大，都可以在一次计算后找到目标（不考虑冲突的话） O(n)： 代表数据量增大几倍，耗时也增大几倍。比如常见的遍历算法。 O(n^2)： 代表数据量增大n倍时，耗时增大n的平方倍，这是比线性更高的时间复杂度。比如冒泡排序，就是典型的O(n^2)的算法，对n个数排序，需要扫描n×n次。 O(logn)： 代表当数据增大n倍时，耗时增大logn倍（这里的log是以2为底的，比如，当数据增大256倍时，耗时只增大8倍，是比线性还要低的时间复杂度）。二分查找就是O(logn)的算法，每找一次排除一半的可能，256个数据中查找只要找8次就可以找到目标。 O(nlogn)： 代表n乘以logn，当数据增大256倍时，耗时增大256*8&#x3D;2048倍。这个复杂度高于线性低于平方。归并排序就是O(nlogn)的时间复杂度。 问题二：c1）插入排序（直接插入排序、希尔排序） 2）交换排序（冒泡排序、快速排序）3）选择排序（直接选择排序、堆排序）4）归并排序5）分配排序（基数排序）特点:所需辅助空间最多：归并排序所需辅助空间最少：堆排序平均速度最快：快速排序不稳定：快速排序，希尔排序，堆排序 直接插入排序 基本思想：在要排序的一组数中，假设前面(n-1)[n&gt;&#x3D;2] 个数已经是排好顺序的，现在要把第n 个数插到前面的有序数中，使得这 n个数也是排好顺序的。如此反复循环，直到全部排好顺序 12345678910111213141516/** * 插入排序法 * * @param datas */ public static int[] sortInsert(int[] datas) &#123; for (int i = 1; i &lt; datas.length; i++) &#123; int j = i - 1; AlgorithmUtil.temp = datas[i]; for (; j &gt;= 0 &amp;&amp; AlgorithmUtil.temp &lt; datas[j]; j--) &#123; datas[j + 1] = datas[j]; &#125; datas[j + 1] = AlgorithmUtil.temp; &#125; return datas; &#125; 简单选择排序 基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。 1234567891011121314151617/** * 选择排序 * * @return */ public static int[] sortSelect(int[] datas) &#123; for (int i = 0; i &lt; datas.length; i++) &#123; int index = i; for (int j = i + 1; j &lt; datas.length; j++) &#123; if (datas[j] &lt; datas[index]) index = j; &#125; if (i != index) AlgorithmUtil.swap(datas, i, index); &#125; return datas; &#125; 冒泡排序 基本思想：在要排序的一组数中，对当前还未排好序的范围内的全部数，自上而下对相邻的两个数依次进行比较和调整，让较大的数往下沉，较小的往上冒。即：每当两相邻的数比较后发现它们的排序与排序要求相反时，就将它们互换。 1234567891011121314/** * 冒泡排序 * * @return */ public static int[] sortBubble(int[] datas) &#123; for (int i = 0; i &lt; datas.length - 1; i++) &#123; for (int j = 0; j &lt; datas.length - 1 - i; j++) &#123; if (datas[j] &gt; datas[j + 1]) AlgorithmUtil.swap(datas, j, j + 1); &#125; &#125; return datas; &#125; 快速排序 基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。 1234567891011121314151617181920212223242526272829303132/** * 快速排序；分割数组 * * @param datas */ public static int QuickPartition(int[] datas, int left, int right) &#123; int pivot = datas[left]; while (left &lt; right) &#123; while (left &lt; right &amp;&amp; datas[right] &gt;= pivot) --right; datas[left] = datas[right]; // 将比枢轴小的元素移到低端，此时right位相当于空，等待低位比pivotkey大的数补上 while (left &lt; right &amp;&amp; datas[left] &lt;= pivot) ++left; datas[right] = datas[left]; // 将比枢轴大的元素移到高端，此时left位相当于空，等待高位比pivotkey小的数补上 &#125; datas[left] = pivot; // 当left == right，完成一趟快速排序，此时left位相当于空，等待pivotkey补上 return left; &#125; /** * 快速排序；递归返回数组 * * @param datas */ public static int[] sortQuick(int[] datas, int left, int right) &#123; if (left &lt; right) &#123; int data = QuickPartition(datas, left, right); sortQuick(datas, left, data - 1); sortQuick(datas, data + 1, right); &#125; return datas; &#125; 1.冒泡算法，2.选择算法，3.快速算法。4.插入算法，5.希尔算法，6.堆算法 基本思想：在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，如此循环到倒数第二个数和最后一个数比较为止。 123456789101112131415161718192021222324252627282930313233343536public class AlgorithmUtil &#123; public static int temp,index = 0; /** * 临时值交换 * * @param datas * 数组 * @param i * @param j */ public static void swap(int[] datas, int i, int j) &#123; temp = datas[i]; datas[i] = datas[j]; datas[j] = temp; &#125; /** * 扩充数组长度 * * @param datas * @param value * @return */ public static int[] expandArray(int[] datas, int value) &#123; if (datas.length &lt;= index) &#123; int[] arrays = new int[datas.length * 2]; System.arraycopy(datas, 0, arrays, 0, datas.length); datas = arrays; &#125; datas[index] = value; index++; return datas; &#125; &#125;","tags":[{"name":"JAVA数据结构和算法","slug":"JAVA数据结构和算法","permalink":"http://example.com/tags/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}],"categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]},{"title":"DB","date":"2022-05-12T09:35:21.862Z","path":"blog/DB/oracle/db2/","text":"DB","tags":[],"categories":[{"name":"DB","slug":"DB","permalink":"http://example.com/categories/DB/"},{"name":"oracle","slug":"DB/oracle","permalink":"http://example.com/categories/DB/oracle/"}]},{"title":"test","date":"2022-05-12T09:35:21.857Z","path":"blog/DB/mysql/test/","text":"test","tags":[],"categories":[{"name":"DB","slug":"DB","permalink":"http://example.com/categories/DB/"},{"name":"mysql","slug":"DB/mysql","permalink":"http://example.com/categories/DB/mysql/"}]},{"title":"mysql1","date":"2022-05-12T09:35:21.855Z","path":"blog/DB/mysql/mysql/","text":"test","tags":[],"categories":[{"name":"DB","slug":"DB","permalink":"http://example.com/categories/DB/"},{"name":"mysql","slug":"DB/mysql","permalink":"http://example.com/categories/DB/mysql/"}]},{"title":"","date":"2022-05-12T09:35:21.848Z","path":"blog/index/","text":"Welcome TaoLiu’s Blog","tags":[],"categories":[]},{"title":"cloud基础","date":"2022-05-12T09:35:21.844Z","path":"blog/Cloud/Cloud基础/","text":"cloud基础","tags":[],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"}]},{"title":"cloud原理","date":"2022-05-12T09:35:21.842Z","path":"blog/Cloud/cloud原理/","text":"cloud原理","tags":[],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"}]},{"title":"Hello hexo","date":"2022-05-12T09:35:21.839Z","path":"blog/hello-hexo/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[],"categories":[]}],"categories":[{"name":"Cloud","slug":"Cloud","permalink":"http://example.com/categories/Cloud/"},{"name":"SpringCloud","slug":"Cloud/SpringCloud","permalink":"http://example.com/categories/Cloud/SpringCloud/"},{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"http://example.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"},{"name":"DB","slug":"DB","permalink":"http://example.com/categories/DB/"},{"name":"oracle","slug":"DB/oracle","permalink":"http://example.com/categories/DB/oracle/"},{"name":"mysql","slug":"DB/mysql","permalink":"http://example.com/categories/DB/mysql/"}],"tags":[{"name":"JAVA数据结构和算法","slug":"JAVA数据结构和算法","permalink":"http://example.com/tags/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"}]}