<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    
    <title>RocketMQ-生产者源码 | TaoLiu-Blog</title>
    
    
        <meta name="keywords" content="RocketMQ">
    
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="description" content="普通消息不论同步请求还是异步请求最终都是调用 DefaultMQProducerImpl 的 sendDefaultImpl 方法,首先通过 tryToFindTopicPublishInfo 方法获取Topic信息,先从本地缓存找,若本地缓存没有则调用 MQClientAPIImpl 的 getTopicRouteInfoFromNameServer 方法通过 RequestCode.GET_R">
<meta property="og:type" content="article">
<meta property="og:title" content="RocketMQ-生产者源码">
<meta property="og:url" content="http://example.com/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/RocketMQ-%E7%94%9F%E4%BA%A7%E8%80%85%E6%BA%90%E7%A0%81/index.html">
<meta property="og:site_name" content="TaoLiu-Blog">
<meta property="og:description" content="普通消息不论同步请求还是异步请求最终都是调用 DefaultMQProducerImpl 的 sendDefaultImpl 方法,首先通过 tryToFindTopicPublishInfo 方法获取Topic信息,先从本地缓存找,若本地缓存没有则调用 MQClientAPIImpl 的 getTopicRouteInfoFromNameServer 方法通过 RequestCode.GET_R">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/assets/png/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF.png">
<meta property="article:published_time" content="2019-04-23T03:08:20.000Z">
<meta property="article:modified_time" content="2022-06-02T09:38:27.313Z">
<meta property="article:author" content="Tao Liu">
<meta property="article:tag" content="RocketMQ">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/assets/png/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF.png">
    

    
        <link rel="alternate" href="/atom.xml" title="TaoLiu-Blog" type="application/atom+xml">
    

    
        <link rel="icon" href="/favicon.ico">
    

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/libs/open-sans/styles.css">

    
<link rel="stylesheet" href="/libs/source-code-pro/styles.css">


    
<link rel="stylesheet" href="/css/style.css">

    
<script src="/libs/jquery/2.1.3/jquery.min.js"></script>

    
<script src="/libs/jquery/plugins/cookie/1.4.1/jquery.cookie.js"></script>

    
    
        
<link rel="stylesheet" href="/libs/lightgallery/css/lightgallery.min.css">

    
    
        
<link rel="stylesheet" href="/libs/justified-gallery/justifiedGallery.min.css">

    
    
    
    


    
        <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
<meta name="generator" content="Hexo 5.4.2"></head>

<body>
    <div id="container">
        <header id="header">
    <div id="header-main" class="header-inner">
        <div class="outer">
            <a href="/" id="logo">
                <i class="logo"></i>
                <span class="site-title">TaoLiu-Blog</span>
            </a>
            <nav id="main-nav">
                
                    <a class="main-nav-link" href="/">Home</a>
                
                    <a class="main-nav-link" href="/archives">Archives</a>
                
                    <a class="main-nav-link" href="/categories">Categories</a>
                
                    <a class="main-nav-link" href="/tags">Tags</a>
                
                    <a class="main-nav-link" href="/about">About</a>
                
            </nav>
            
            <div id="search-form-wrap">

    <form class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
        <button type="submit" class="search-form-submit"></button>
    </form>
    <div class="ins-search">
    <div class="ins-search-mask"></div>
    <div class="ins-search-container">
        <div class="ins-input-wrapper">
            <input type="text" class="ins-search-input" placeholder="Type something...">
            <span class="ins-close ins-selectable"><i class="fa fa-times-circle"></i></span>
        </div>
        <div class="ins-section-wrapper">
            <div class="ins-section-container"></div>
        </div>
    </div>
</div>
<script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>


</div>
        </div>
    </div>
    <div id="main-nav-mobile" class="header-sub header-inner">
        <table class="menu outer">
            <tr>
                
                    <td><a class="main-nav-link" href="/">Home</a></td>
                
                    <td><a class="main-nav-link" href="/archives">Archives</a></td>
                
                    <td><a class="main-nav-link" href="/categories">Categories</a></td>
                
                    <td><a class="main-nav-link" href="/tags">Tags</a></td>
                
                    <td><a class="main-nav-link" href="/about">About</a></td>
                
                <td>
                    
    <div class="search-form">
        <input type="text" class="ins-search-input search-form-input" placeholder="Search">
    </div>

                </td>
            </tr>
        </table>
    </div>
</header>

        <div class="outer">
            
            
                <aside id="sidebar">
   
        
    <div class="widget-wrap" id="categories">
        <h3 class="widget-title">
            <span>categories</span>
            &nbsp;
            <a id="allExpand" href="#">
                <i class="fa fa-angle-double-down fa-2x"></i>
            </a>
        </h3>
        
        
        
         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Cloud
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Redis
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/blog/Cloud/Redis/Redis%E5%9F%BA%E7%A1%80/">Redis基础</a></li>  <li class="file"><a href="/blog/Cloud/Redis/Redis%E5%AE%89%E8%A3%85/">Redis安装</a></li>  <li class="file"><a href="/blog/Cloud/Redis/Redis%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/">Redis集群架构</a></li>  <li class="file"><a href="/blog/Cloud/Redis/Redis%E5%AE%9E%E8%B7%B5-Java/">Redis实践-Java</a></li>  <li class="file"><a href="/blog/Cloud/Redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E7%8E%B0/">Redis分布式锁实现</a></li>  <li class="file"><a href="/blog/Cloud/Redis/Redis%E7%BC%93%E5%AD%98%E5%8F%8A%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">Redis缓存及性能优化</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            SpringCloud
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/blog/Cloud/SpringCloud/SpringCloud/">SpringCloud介绍</a></li>  <li class="file"><a href="/blog/Cloud/SpringCloud/SpringCloud%E7%B3%BB%E5%88%971-%E7%88%B6%E5%AD%90(%E8%81%9A%E5%90%88)%E9%A1%B9%E7%9B%AE/">SpringCloud系列1-父子(聚合)项目</a></li>  <li class="file"><a href="/blog/Cloud/SpringCloud/SpringCloud%E7%B3%BB%E5%88%972-%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/">SpringCloud系列2-服务注册中心</a></li>  <li class="file"><a href="/blog/Cloud/SpringCloud/SpringCloud%E7%B3%BB%E5%88%973-%E6%B3%A8%E5%86%8C%E6%95%B0%E6%8D%AE%E5%BE%AE%E6%9C%8D%E5%8A%A1/">SpringCloud系列3-注册数据微服务</a></li>  <li class="file"><a href="/blog/Cloud/SpringCloud/SpringCloud%E7%B3%BB%E5%88%974-%E8%A7%86%E5%9B%BE%E5%BE%AE%E6%9C%8D%E5%8A%A1-RIBBON/">SpringCloud系列4-视图微服务-RIBBON</a></li>  <li class="file"><a href="/blog/Cloud/SpringCloud/SpringCloud%E7%B3%BB%E5%88%975-%E8%A7%86%E5%9B%BE%E5%BE%AE%E6%9C%8D%E5%8A%A1-Feign/">SpringCloud系列5-视图微服务-Feign</a></li>  <li class="file"><a href="/blog/Cloud/SpringCloud/SpringCloud%E7%B3%BB%E5%88%976-%E6%9C%8D%E5%8A%A1%E9%93%BE%E8%B7%AF%E8%BF%BD%E8%B8%AA/">SpringCloud系列6-服务链路追踪</a></li>  <li class="file"><a href="/blog/Cloud/SpringCloud/SpringCloud%E7%B3%BB%E5%88%977-%E9%85%8D%E7%BD%AE%E6%9C%8D%E5%8A%A1%E5%99%A8/">SpringCloud系列7-配置服务器</a></li>  <li class="file"><a href="/blog/Cloud/SpringCloud/SpringCloud%E7%B3%BB%E5%88%978-%E9%85%8D%E7%BD%AE%E5%AE%A2%E6%88%B7%E7%AB%AF/">SpringCloud系列8-配置客户端</a></li>  <li class="file"><a href="/blog/Cloud/SpringCloud/SpringCloud%E7%B3%BB%E5%88%979-%E6%B6%88%E6%81%AF%E6%80%BB%E7%BA%BFBus/">SpringCloud系列9-消息总线Bus</a></li>  <li class="file"><a href="/blog/Cloud/SpringCloud/SpringCloud%E7%B3%BB%E5%88%9710-%E6%96%AD%E8%B7%AF%E5%99%A8Hystrix/">SpringCloud系列10-断路器Hystrix</a></li>  <li class="file"><a href="/blog/Cloud/SpringCloud/SpringCloud%E7%B3%BB%E5%88%9711-%E6%96%AD%E8%B7%AF%E5%99%A8%E7%9B%91%E6%8E%A7/">SpringCloud系列11-断路器监控</a></li>  <li class="file"><a href="/blog/Cloud/SpringCloud/SpringCloud%E7%B3%BB%E5%88%9712-%E6%96%AD%E8%B7%AF%E5%99%A8%E8%81%9A%E5%90%88%E7%9B%91%E6%8E%A7/">SpringCloud系列12-断路器聚合监控</a></li>  <li class="file"><a href="/blog/Cloud/SpringCloud/SpringCloud%E7%B3%BB%E5%88%9713-%E7%BD%91%E5%85%B3Zuul/">SpringCloud系列13-网关Zuul</a></li>  <li class="file"><a href="/blog/Cloud/SpringCloud/SpringCloud%E7%B3%BB%E5%88%9714-%E6%80%BB%E7%BB%93/">SpringCloud系列14-总结</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/blog/Cloud/Gateway%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Gateway源码分析</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            工具和中间件
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            搜索引擎技术
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            ElasticSearch
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF/ElasticSearch/ElasticSearch%E5%9F%BA%E7%A1%80/">ElasticSearch基础</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF/ElasticSearch/ElasticSearch%E5%AE%9E%E6%88%98/">ElasticSearch实战</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF/ElasticSearch/ElasticSearch%E8%BF%9B%E9%98%B6/">ElasticSearch进阶</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF/ElasticSearch/ElasticSearch%E5%B7%A5%E5%85%B7-Kibana/">ElasticSearch工具-Kibana</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF/ElasticSearch/ElasticSearch-Springboot/">ElasticSearch-Springboot</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Lucene
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF/Lucene/Lucene%E5%9F%BA%E7%A1%80/">Lucene基础</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF/Lucene/Lucene%E5%88%86%E8%AF%8D%E5%99%A8/">Lucene分词器</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF/Lucene/Lucene%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2/">Lucene分页查询</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF/Lucene/Lucene%E7%B4%A2%E5%BC%95%E5%88%A0%E9%99%A4%E5%92%8C%E6%9B%B4%E6%96%B0/">Lucene索引删除和更新</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Solr
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF/Solr/Solr%E5%9F%BA%E7%A1%80/">Solr基础</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF/Solr/Solr%E4%B8%AD%E6%96%87%E5%88%86%E8%AF%8D%E5%99%A8IKAnalyzer/">Solr中文分词器IKAnalyzer</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF/Solr/Solr%E8%AE%BE%E7%BD%AE%E5%AD%97%E6%AE%B5/">Solr设置字段</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF/Solr/Solr%E5%88%9B%E5%BB%BA%E7%B4%A2%E5%BC%95/">Solr创建索引</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF/Solr/Solr%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2-Solrj/">Solr分页查询-Solrj</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF/Solr/Solr%E9%AB%98%E4%BA%AE%E6%98%BE%E7%A4%BA/">Solr高亮显示</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E6%8A%80%E6%9C%AF/Solr/Solr%E6%9B%B4%E6%96%B0%E5%92%8C%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95/">Solr更新和删除索引</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            消息队列
                        </a>
                         <ul class="unstyled" id="tree"> 
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Activemq
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Activemq/ActiveMQ-%E5%9F%BA%E7%A1%80/">ActiveMQ-基础</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Activemq/ActiveMQ-%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F/">ActiveMQ-队列模式</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Activemq/ActiveMQ-%E4%B8%BB%E9%A2%98%E6%A8%A1%E5%BC%8F/">ActiveMQ-主题模式</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Activemq/ActiveMQ-Spring%E9%9B%86%E6%88%90/">ActiveMQ-Spring集成</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            Kafka
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/Kafka-%E5%9F%BA%E7%A1%80/">Kafka-基础</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/Kafka/Kafka-Spring%E9%9B%86%E6%88%90/">Kafka-Spring集成</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            RabbitMQ
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ-%E5%9F%BA%E7%A1%80/">RabbitMQ-基础</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ-fanout%E6%A8%A1%E5%BC%8F/">RabbitMQ-fanout模式</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ-direct%E6%A8%A1%E5%BC%8F/">RabbitMQ-direct模式</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ-topic%E6%A8%A1%E5%BC%8F/">RabbitMQ-topic模式</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ-%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7/">RabbitMQ-高级特性</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RabbitMQ/RabbitMQ-Spring%E9%9B%86%E6%88%90/">RabbitMQ-Spring集成</a></li>  </ul> 
                    </li> 
                    
                    <li class="directory open">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder-open"></i>
                            &nbsp;
                            RocketMQ
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/RocketMQ-%E5%9F%BA%E7%A1%80/">RocketMQ-基础</a></li>  <li class="file active"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/RocketMQ-%E7%94%9F%E4%BA%A7%E8%80%85%E6%BA%90%E7%A0%81/">RocketMQ-生产者源码</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/RocketMQ-%E6%B6%88%E8%B4%B9%E8%80%85%E6%BA%90%E7%A0%81/">RocketMQ-消费者源码</a></li>  <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/RocketMQ-Spring%E9%9B%86%E6%88%90/">RocketMQ-Spring集成</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a></li>  </ul> 
                    </li> 
                     </ul> 
                    </li> 
                    
                    <li class="directory">
                        <a href="#" data-role="directory">
                            <i class="fa fa-folder"></i>
                            &nbsp;
                            数据结构和算法
                        </a>
                         <ul class="unstyled" id="tree">  <li class="file"><a href="/blog/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/JAVA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/">JAVA数据结构和算法</a></li>  </ul> 
                    </li> 
                     <li class="file"><a href="/blog/hello-hexo/">Hello hexo</a></li>  <li class="file"><a href="/blog/index/">Welcome TaoLiu's Blog</a></li>  </ul> 
    </div>
    <script>
        $(document).ready(function() {
            var iconFolderOpenClass  = 'fa-folder-open';
            var iconFolderCloseClass = 'fa-folder';
            var iconAllExpandClass = 'fa-angle-double-down';
            var iconAllPackClass = 'fa-angle-double-up';
            // Handle directory-tree expansion:
            // 左键单独展开目录
            $(document).on('click', '#categories a[data-role="directory"]', function (event) {
                event.preventDefault();

                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var subtree = $(this).siblings('ul');
                icon.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if (expanded) {
                    if (typeof subtree != 'undefined') {
                        subtree.slideUp({ duration: 100 });
                    }
                    icon.addClass(iconFolderCloseClass);
                } else {
                    if (typeof subtree != 'undefined') {
                        subtree.slideDown({ duration: 100 });
                    }
                    icon.addClass(iconFolderOpenClass);
                }
            });
            // 右键展开下属所有目录
            $('#categories a[data-role="directory"]').bind("contextmenu", function(event){
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconFolderOpenClass);
                var listNode = $(this).siblings('ul');
                var subtrees = $.merge(listNode.find('li ul'), listNode);
                var icons = $.merge(listNode.find('.fa'), icon);
                icons.removeClass(iconFolderOpenClass).removeClass(iconFolderCloseClass);
                if(expanded) {
                    subtrees.slideUp({ duration: 100 });
                    icons.addClass(iconFolderCloseClass);
                } else {
                    subtrees.slideDown({ duration: 100 });
                    icons.addClass(iconFolderOpenClass);
                }
            })
            // 展开关闭所有目录按钮
            $(document).on('click', '#allExpand', function (event) {
                event.preventDefault();
                
                var icon = $(this).children('.fa');
                var expanded = icon.hasClass(iconAllExpandClass);
                icon.removeClass(iconAllExpandClass).removeClass(iconAllPackClass);
                if(expanded) {
                    $('#sidebar .fa.fa-folder').removeClass('fa-folder').addClass('fa-folder-open')
                    $('#categories li ul').slideDown({ duration: 100 });
                    icon.addClass(iconAllPackClass);
                } else {
                    $('#sidebar .fa.fa-folder-open').removeClass('fa-folder-open').addClass('fa-folder')
                    $('#categories li ul').slideUp({ duration: 100 });
                    icon.addClass(iconAllExpandClass);
                }
            });  
        });
    </script>

    
    <div id="toTop" class="fa fa-angle-up"></div>
</aside>
            
            <section id="main"><article id="post-工具和中间件/消息队列/RocketMQ/RocketMQ-生产者源码" class="article article-type-post" itemscope itemprop="blogPost">
    <div class="article-inner">
        
        
            <header class="article-header">
                
                    <div class="article-meta">
                        
    <div class="article-category">
    	<i class="fa fa-folder"></i>
        <a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/">工具和中间件</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/">消息队列</a><i class="fa fa-angle-right"></i><a class="article-category-link" href="/categories/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/">RocketMQ</a>
    </div>

                        
    <div class="article-tag">
        <i class="fa fa-tag"></i>
        <a class="tag-link-link" href="/tags/RocketMQ/" rel="tag">RocketMQ</a>
    </div>

                        
    <div class="article-date">
        <i class="fa fa-calendar"></i>
        <a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/RocketMQ-%E7%94%9F%E4%BA%A7%E8%80%85%E6%BA%90%E7%A0%81/">
            <time datetime="2019-04-23T03:08:20.000Z" itemprop="datePublished">2019-04-23</time>
        </a>
    </div>


                        
                            <i class="fa fa-bar-chart"></i>
                            <span id="busuanzi_container_site_pv"><span id="busuanzi_value_page_pv"></span></span>    
                        
                        
                    </div>
                
                
    
        <h1 class="article-title" itemprop="name">
            RocketMQ-生产者源码
        </h1>
    

            </header>
        
        
        <div class="article-entry" itemprop="articleBody">
        
        
            
        
        
            <h2 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h2><p>不论<strong>同步</strong>请求还是<strong>异步</strong>请求最终都是调用 <strong><code>DefaultMQProducerImpl</code></strong> 的 <strong><code>sendDefaultImpl</code></strong> 方法,首先通过 <strong><code>tryToFindTopicPublishInfo</code></strong> 方法获取Topic信息,先从本地缓存找,若本地缓存没有则调用 <strong><code>MQClientAPIImpl</code></strong> 的 <strong><code>getTopicRouteInfoFromNameServer</code></strong> 方法通过 <strong><code>RequestCode.GET_ROUTEINFO_BY_TOPIC</code></strong> 关联调用NameServer的 <strong><code>DefaultRequestProcessor</code></strong> 的 <strong><code>getRouteInfoByTopic</code></strong> 方法获取Topic信息； <strong><code>Topic</code></strong> 信息在 <strong><code>Producter</code></strong> 启动时就注册到 <strong><code>NameServer</code></strong> 了,且每 <strong><code>30s</code></strong> 发送心跳也会发送 <strong><code>Topic</code></strong> 相关的信息.</p>
<p>然后通过 <strong><code>MQFaultStrategy</code></strong> 的 <strong><code>selectOneMessageQueue</code></strong> 获取具体的具体要将消息发送到哪一个队列中,Producer选择 <strong><code>MessageQueue</code></strong> 方法是<strong>消息数自增对队列数取模</strong>,可通过 <strong><code>sendLatencyFaultEnable</code></strong> 参数开启Broker<strong>故障延迟机制</strong>,发送消息失败后一定时间内不在往同一个Queue重复发送的机制,在 <strong><code>LatencyFaultToleranceImpl</code></strong> 中维护了<strong>曾经发送失败的Broker列表到<code>faultItemTable</code></strong> 中.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultMQProducer extends ClientConfig implements MQProducer &#123;</span><br><span class="line">    public SendResult send(Message msg) throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">        Validators.checkMessage(msg, this);</span><br><span class="line">        msg.setTopic(withNamespace(msg.getTopic()));</span><br><span class="line">        return this.defaultMQProducerImpl.send(msg);</span><br><span class="line">    &#125;</span><br><span class="line">    public void send(Message msg, SendCallback sendCallback) throws MQClientException, RemotingException, InterruptedException &#123;</span><br><span class="line">        msg.setTopic(withNamespace(msg.getTopic()));</span><br><span class="line">        this.defaultMQProducerImpl.send(msg, sendCallback);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DefaultMQProducerImpl implements MQProducerInner &#123;</span><br><span class="line">    public void send(final Message msg, final SendCallback sendCallback, final long timeout) throws MQClientException, RemotingException, InterruptedException &#123;</span><br><span class="line">        final long beginStartTime = System.currentTimeMillis();</span><br><span class="line">        ExecutorService executor = this.getAsyncSenderExecutor();</span><br><span class="line">        try &#123;</span><br><span class="line">            executor.submit(new Runnable() &#123;</span><br><span class="line">                @Override public void run() &#123;</span><br><span class="line">                    long costTime = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                    if (timeout &gt; costTime) &#123;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            sendDefaultImpl(msg, CommunicationMode.ASYNC, sendCallback, timeout - costTime);</span><br><span class="line">                        &#125; catch (Exception e) &#123;</span><br><span class="line">                            sendCallback.onException(e); // 调用回调方法</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; else &#123; // 调用回调方法</span><br><span class="line">                        sendCallback.onException(new RemotingTooMuchRequestException(&quot;DEFAULT ASYNC send call timeout&quot;));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125; catch (RejectedExecutionException e) &#123;</span><br><span class="line">            throw new MQClientException(&quot;executor rejected &quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private SendResult sendDefaultImpl(Message msg, final CommunicationMode communicationMode, final SendCallback sendCallback, final long timeout) throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">        this.makeSureStateOK();</span><br><span class="line">        Validators.checkMessage(msg, this.defaultMQProducer);</span><br><span class="line">        final long invokeID = random.nextLong();</span><br><span class="line">        long beginTimestampFirst = System.currentTimeMillis();</span><br><span class="line">        long beginTimestampPrev = beginTimestampFirst;</span><br><span class="line">        long endTimestamp = beginTimestampFirst;</span><br><span class="line">        // 生产者获取Topic的公开信息</span><br><span class="line">        TopicPublishInfo topicPublishInfo = this.tryToFindTopicPublishInfo(msg.getTopic());</span><br><span class="line">        if (topicPublishInfo != null &amp;&amp; topicPublishInfo.ok()) &#123;</span><br><span class="line">            boolean callTimeout = false;</span><br><span class="line">            MessageQueue mq = null;</span><br><span class="line">            Exception exception = null;</span><br><span class="line">            SendResult sendResult = null;</span><br><span class="line">            int timesTotal = communicationMode == CommunicationMode.SYNC ? 1 + this.defaultMQProducer.getRetryTimesWhenSendFailed() : 1;</span><br><span class="line">            int times = 0;</span><br><span class="line">            String[] brokersSent = new String[timesTotal];</span><br><span class="line">            for (; times &lt; timesTotal; times++) &#123; // 重试次数,异步默认重试2次共3次,同步不重试共1次</span><br><span class="line">                String lastBrokerName = null == mq ? null : mq.getBrokerName();</span><br><span class="line">                // Producer计算把消息发到哪个MessageQueue中,自增然后取模</span><br><span class="line">                MessageQueue mqSelected = this.selectOneMessageQueue(topicPublishInfo, lastBrokerName);</span><br><span class="line">                if (mqSelected != null) &#123;</span><br><span class="line">                    mq = mqSelected;</span><br><span class="line">                    brokersSent[times] = mq.getBrokerName(); // 根据MessageQueue去获取目标节点的信息.</span><br><span class="line">                    try &#123;</span><br><span class="line">                        beginTimestampPrev = System.currentTimeMillis();</span><br><span class="line">                        if (times &gt; 0) &#123; // 重新发送期间使用命名空间重置主题</span><br><span class="line">                            msg.setTopic(this.defaultMQProducer.withNamespace(msg.getTopic()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        long costTime = beginTimestampPrev - beginTimestampFirst;</span><br><span class="line">                        if (timeout &lt; costTime) &#123;  // 判断是否超时,默认3s</span><br><span class="line">                            callTimeout = true;</span><br><span class="line">                            break; // 若超时</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 实际发送消息的方法</span><br><span class="line">                        sendResult = this.sendKernelImpl(msg, mq, communicationMode, sendCallback, topicPublishInfo, timeout - costTime);</span><br><span class="line">                        endTimestamp = System.currentTimeMillis();</span><br><span class="line">                        this.updateFaultItem(mq.getBrokerName(), endTimestamp - beginTimestampPrev, false);</span><br><span class="line">                        switch (communicationMode) &#123;</span><br><span class="line">                            case ASYNC:</span><br><span class="line">                                return null; // 异步发送返回null</span><br><span class="line">                            case ONEWAY:</span><br><span class="line">                                return null; // 单向发送返回null</span><br><span class="line">                            case SYNC:</span><br><span class="line">                                if (sendResult.getSendStatus() != SendStatus.SEND_OK) &#123;</span><br><span class="line">                                    if (this.defaultMQProducer.isRetryAnotherBrokerWhenNotStoreOK()) &#123;</span><br><span class="line">                                        continue; // 若重试则继续,否则直接返回结果</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125;</span><br><span class="line">                                return sendResult;</span><br><span class="line">                            default:</span><br><span class="line">                                break;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (sendResult != null) &#123;</span><br><span class="line">                return sendResult;</span><br><span class="line">            &#125;</span><br><span class="line">            info += FAQUrl.suggestTodo(FAQUrl.SEND_MSG_FAILED);</span><br><span class="line">            MQClientException mqClientException = new MQClientException(info, exception);</span><br><span class="line">            if (callTimeout) &#123;</span><br><span class="line">                throw new RemotingTooMuchRequestException(&quot;sendDefaultImpl call timeout&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            throw mqClientException;</span><br><span class="line">        &#125;</span><br><span class="line">        validateNameServerSetting();</span><br><span class="line">        throw new MQClientException(&quot;No route info of this topic: &quot; + msg.getTopic() + FAQUrl.suggestTodo(FAQUrl.NO_TOPIC_ROUTE_INFO), null).setResponseCode(ClientErrorCode.NOT_FOUND_TOPIC_EXCEPTION);</span><br><span class="line">    &#125;</span><br><span class="line">    public MessageQueue selectOneMessageQueue(final TopicPublishInfo tpInfo, final String lastBrokerName) &#123;</span><br><span class="line">        return this.mqFaultStrategy.selectOneMessageQueue(tpInfo, lastBrokerName);</span><br><span class="line">    &#125;</span><br><span class="line">    // 找路由表的过程都是先从本地缓存找,本地缓存没有,就去NameServer上申请.</span><br><span class="line">    private TopicPublishInfo tryToFindTopicPublishInfo(final String topic) &#123;</span><br><span class="line">        TopicPublishInfo topicPublishInfo = this.topicPublishInfoTable.get(topic);</span><br><span class="line">        if (null == topicPublishInfo || !topicPublishInfo.ok()) &#123;</span><br><span class="line">            this.topicPublishInfoTable.putIfAbsent(topic, new TopicPublishInfo());</span><br><span class="line">            // Producer向NameServer获取更新Topic的路由信息.</span><br><span class="line">            this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span><br><span class="line">            // 还是从本地缓存中寻找Topic路由信息.</span><br><span class="line">            topicPublishInfo = this.topicPublishInfoTable.get(topic);</span><br><span class="line">        &#125;</span><br><span class="line">        if (topicPublishInfo.isHaveTopicRouterInfo() || topicPublishInfo.ok()) &#123;</span><br><span class="line">            return topicPublishInfo;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic, true, this.defaultMQProducer);</span><br><span class="line">            topicPublishInfo = this.topicPublishInfoTable.get(topic);</span><br><span class="line">            return topicPublishInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MQFaultStrategy &#123;</span><br><span class="line">    public MessageQueue selectOneMessageQueue(final TopicPublishInfo tpInfo, final String lastBrokerName) &#123;</span><br><span class="line">        // sendLatencyFaultEnable默认关闭,Broker故障延迟机制,表示一种发送消息失败后一定时间内不在往同一个Queue重复发送的机制</span><br><span class="line">        if (this.sendLatencyFaultEnable) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // Producer选择MessageQueue的方法是自增然后取模.</span><br><span class="line">                int index = tpInfo.getSendWhichQueue().getAndIncrement();</span><br><span class="line">                for (int i = 0; i &lt; tpInfo.getMessageQueueList().size(); i++) &#123;</span><br><span class="line">                    int pos = Math.abs(index++) % tpInfo.getMessageQueueList().size();</span><br><span class="line">                    if (pos &lt; 0)</span><br><span class="line">                        pos = 0;</span><br><span class="line">                    MessageQueue mq = tpInfo.getMessageQueueList().get(pos);</span><br><span class="line">                    // Broker轮询,尽量将请求平均分配给不同的Broker</span><br><span class="line">                    if (latencyFaultTolerance.isAvailable(mq.getBrokerName())) &#123;</span><br><span class="line">                        if (null == lastBrokerName || mq.getBrokerName().equals(lastBrokerName))</span><br><span class="line">                            return mq;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                final String notBestBroker = latencyFaultTolerance.pickOneAtLeast();</span><br><span class="line">                int writeQueueNums = tpInfo.getQueueIdByBroker(notBestBroker);</span><br><span class="line">                if (writeQueueNums &gt; 0) &#123; </span><br><span class="line">                    final MessageQueue mq = tpInfo.selectOneMessageQueue();// 自增取模计算</span><br><span class="line">                    if (notBestBroker != null) &#123;</span><br><span class="line">                        mq.setBrokerName(notBestBroker);</span><br><span class="line">                        mq.setQueueId(tpInfo.getSendWhichQueue().getAndIncrement() % writeQueueNums);</span><br><span class="line">                    &#125;</span><br><span class="line">                    return mq;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    latencyFaultTolerance.remove(notBestBroker);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return tpInfo.selectOneMessageQueue(); // 自增取模计算</span><br><span class="line">        &#125;</span><br><span class="line">        return tpInfo.selectOneMessageQueue(lastBrokerName); // 自增取模计算</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TopicPublishInfo &#123; //选择MessageQueue的方式：递增取模</span><br><span class="line">    public MessageQueue selectOneMessageQueue() &#123;</span><br><span class="line">        int index = this.sendWhichQueue.getAndIncrement();</span><br><span class="line">        int pos = Math.abs(index) % this.messageQueueList.size();</span><br><span class="line">        if (pos &lt; 0)</span><br><span class="line">            pos = 0;</span><br><span class="line">        return this.messageQueueList.get(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    public MessageQueue selectOneMessageQueue(final String lastBrokerName) &#123;</span><br><span class="line">        if (lastBrokerName == null) &#123;</span><br><span class="line">            return selectOneMessageQueue();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int index = this.sendWhichQueue.getAndIncrement();</span><br><span class="line">            for (int i = 0; i &lt; this.messageQueueList.size(); i++) &#123;</span><br><span class="line">                int pos = Math.abs(index++) % this.messageQueueList.size();</span><br><span class="line">                if (pos &lt; 0)</span><br><span class="line">                    pos = 0;</span><br><span class="line">                MessageQueue mq = this.messageQueueList.get(pos);</span><br><span class="line">                if (!mq.getBrokerName().equals(lastBrokerName)) &#123;</span><br><span class="line">                    return mq;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return selectOneMessageQueue();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论是<strong>同步</strong>还是<strong>异步</strong>或是单向消息最终都会调用 <strong><code>MQClientAPIImpl</code></strong> 的 <strong><code>sendMessage</code></strong> 方法,不同的是同步方法没有 <strong><code>SendCallback</code></strong> 回调.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line">public class DefaultMQProducerImpl implements MQProducerInner &#123;</span><br><span class="line">    private SendResult sendKernelImpl(final Message msg, final MessageQueue mq, final CommunicationMode communicationMode, final SendCallback sendCallback, final TopicPublishInfo topicPublishInfo, final long timeout)</span><br><span class="line">        throws MQClientException, RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">        long beginStartTime = System.currentTimeMillis();</span><br><span class="line">        String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName()); // 找到Master节点地址</span><br><span class="line">        if (null == brokerAddr) &#123;// 通过Broker名称获取Broker地址,若获取不到则去NameServer上获取.</span><br><span class="line">            tryToFindTopicPublishInfo(mq.getTopic());</span><br><span class="line">            brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(mq.getBrokerName());</span><br><span class="line">        &#125;</span><br><span class="line">        SendMessageContext context = null;</span><br><span class="line">        if (brokerAddr != null) &#123;</span><br><span class="line">            brokerAddr = MixAll.brokerVIPChannel(this.defaultMQProducer.isSendMessageWithVIPChannel(), brokerAddr);</span><br><span class="line">            byte[] prevBody = msg.getBody();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (!(msg instanceof MessageBatch)) &#123; //for MessageBatch,ID has been set in the generating process</span><br><span class="line">                    MessageClientIDSetter.setUniqID(msg); // 批量消息</span><br><span class="line">                &#125;</span><br><span class="line">                boolean topicWithNamespace = false;</span><br><span class="line">                if (null != this.mQClientFactory.getClientConfig().getNamespace()) &#123;</span><br><span class="line">                    msg.setInstanceId(this.mQClientFactory.getClientConfig().getNamespace());</span><br><span class="line">                    topicWithNamespace = true;</span><br><span class="line">                &#125;</span><br><span class="line">                int sysFlag = 0;</span><br><span class="line">                boolean msgBodyCompressed = false;</span><br><span class="line">                if (this.tryToCompressMessage(msg)) &#123; // 消息体大于4K将默认压缩</span><br><span class="line">                    sysFlag |= MessageSysFlag.COMPRESSED_FLAG;</span><br><span class="line">                    msgBodyCompressed = true;</span><br><span class="line">                &#125;</span><br><span class="line">                final String tranMsg = msg.getProperty(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">                if (tranMsg != null &amp;&amp; Boolean.parseBoolean(tranMsg)) &#123;</span><br><span class="line">                    sysFlag |= MessageSysFlag.TRANSACTION_PREPARED_TYPE;</span><br><span class="line">                &#125;</span><br><span class="line">                SendMessageRequestHeader requestHeader = new SendMessageRequestHeader();</span><br><span class="line">                requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());</span><br><span class="line">                requestHeader.setTopic(msg.getTopic());</span><br><span class="line">                requestHeader.setDefaultTopic(this.defaultMQProducer.getCreateTopicKey());</span><br><span class="line">                requestHeader.setDefaultTopicQueueNums(this.defaultMQProducer.getDefaultTopicQueueNums());</span><br><span class="line">                requestHeader.setQueueId(mq.getQueueId());</span><br><span class="line">                requestHeader.setSysFlag(sysFlag);</span><br><span class="line">                requestHeader.setBornTimestamp(System.currentTimeMillis());</span><br><span class="line">                requestHeader.setFlag(msg.getFlag());</span><br><span class="line">                requestHeader.setProperties(MessageDecoder.messageProperties2String(msg.getProperties()));</span><br><span class="line">                requestHeader.setReconsumeTimes(0);</span><br><span class="line">                requestHeader.setUnitMode(this.isUnitMode());</span><br><span class="line">                requestHeader.setBatch(msg instanceof MessageBatch);</span><br><span class="line">                if (requestHeader.getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) &#123; // 重试消息</span><br><span class="line">                    String reconsumeTimes = MessageAccessor.getReconsumeTime(msg);</span><br><span class="line">                    if (reconsumeTimes != null) &#123;</span><br><span class="line">                        requestHeader.setReconsumeTimes(Integer.valueOf(reconsumeTimes));</span><br><span class="line">                        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_RECONSUME_TIME);</span><br><span class="line">                    &#125;</span><br><span class="line">                    String maxReconsumeTimes = MessageAccessor.getMaxReconsumeTimes(msg);</span><br><span class="line">                    if (maxReconsumeTimes != null) &#123;</span><br><span class="line">                        requestHeader.setMaxReconsumeTimes(Integer.valueOf(maxReconsumeTimes));</span><br><span class="line">                        MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_MAX_RECONSUME_TIMES);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                SendResult sendResult = null;</span><br><span class="line">                switch (communicationMode) &#123;</span><br><span class="line">                    case ASYNC:</span><br><span class="line">                        Message tmpMessage = msg;</span><br><span class="line">                        boolean messageCloned = false;</span><br><span class="line">                        if (msgBodyCompressed) &#123;</span><br><span class="line">                            tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">                            messageCloned = true;</span><br><span class="line">                            msg.setBody(prevBody);</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (topicWithNamespace) &#123;</span><br><span class="line">                            if (!messageCloned) &#123;</span><br><span class="line">                                tmpMessage = MessageAccessor.cloneMessage(msg);</span><br><span class="line">                                messageCloned = true;</span><br><span class="line">                            &#125;</span><br><span class="line">                            msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQProducer.getNamespace()));</span><br><span class="line">                        &#125;</span><br><span class="line">                        long costTimeAsync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                        if (timeout &lt; costTimeAsync) &#123;</span><br><span class="line">                            throw new RemotingTooMuchRequestException(&quot;sendKernelImpl call timeout&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 真正向Broker发送消息,异步要传入回调函数</span><br><span class="line">                        sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(brokerAddr, mq.getBrokerName(), tmpMessage, requestHeader, timeout - costTimeAsync, communicationMode, sendCallback, topicPublishInfo, this.mQClientFactory, this.defaultMQProducer.getRetryTimesWhenSendAsyncFailed(), context, this);</span><br><span class="line">                        break;</span><br><span class="line">                    case ONEWAY:</span><br><span class="line">                    case SYNC:</span><br><span class="line">                        long costTimeSync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                        if (timeout &lt; costTimeSync) &#123;</span><br><span class="line">                            throw new RemotingTooMuchRequestException(&quot;sendKernelImpl call timeout&quot;);</span><br><span class="line">                        &#125;</span><br><span class="line">                        // 真正向Broker发送消息,同步不需要传入回调函数</span><br><span class="line">                        sendResult = this.mQClientFactory.getMQClientAPIImpl().sendMessage(brokerAddr, mq.getBrokerName(), msg, requestHeader, timeout - costTimeSync, communicationMode, context, this);</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        assert false;</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                if (this.hasSendMessageHook()) &#123;//消息发送完成后执行钩子程序.</span><br><span class="line">                    context.setSendResult(sendResult);</span><br><span class="line">                    this.executeSendMessageHookAfter(context);</span><br><span class="line">                &#125;</span><br><span class="line">                return sendResult;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new MQClientException(&quot;The broker[&quot; + mq.getBrokerName() + &quot;] not exist&quot;, null);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MQClientAPIImpl &#123; // 不论同步还是异步最终都会调用该方法</span><br><span class="line">    public SendResult sendMessage(final String addr, final String brokerName, final Message msg, final SendMessageRequestHeader requestHeader, final long timeoutMillis, final CommunicationMode communicationMode, final SendCallback sendCallback, final TopicPublishInfo topicPublishInfo, final MQClientInstance instance, final int retryTimesWhenSendFailed, final SendMessageContext context, final DefaultMQProducerImpl producer) throws RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">        long beginStartTime = System.currentTimeMillis();</span><br><span class="line">        RemotingCommand request = null;</span><br><span class="line">        String msgType = msg.getProperty(MessageConst.PROPERTY_MESSAGE_TYPE);</span><br><span class="line">        boolean isReply = msgType != null &amp;&amp; msgType.equals(MixAll.REPLY_MESSAGE_FLAG);</span><br><span class="line">        if (isReply) &#123;</span><br><span class="line">            if (sendSmartMsg) &#123;</span><br><span class="line">                SendMessageRequestHeaderV2 requestHeaderV2 = SendMessageRequestHeaderV2.createSendMessageRequestHeaderV2(requestHeader);</span><br><span class="line">                request = RemotingCommand.createRequestCommand(RequestCode.SEND_REPLY_MESSAGE_V2, requestHeaderV2);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                request = RemotingCommand.createRequestCommand(RequestCode.SEND_REPLY_MESSAGE, requestHeader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (sendSmartMsg || msg instanceof MessageBatch) &#123;</span><br><span class="line">                SendMessageRequestHeaderV2 requestHeaderV2 = SendMessageRequestHeaderV2.createSendMessageRequestHeaderV2(requestHeader);</span><br><span class="line">                request = RemotingCommand.createRequestCommand(msg instanceof MessageBatch ? RequestCode.SEND_BATCH_MESSAGE : RequestCode.SEND_MESSAGE_V2, requestHeaderV2);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                request = RemotingCommand.createRequestCommand(RequestCode.SEND_MESSAGE, requestHeader);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        request.setBody(msg.getBody());</span><br><span class="line">        switch (communicationMode) &#123;</span><br><span class="line">            case ONEWAY:</span><br><span class="line">                this.remotingClient.invokeOneway(addr, request, timeoutMillis);</span><br><span class="line">                return null;</span><br><span class="line">            case ASYNC:</span><br><span class="line">                final AtomicInteger times = new AtomicInteger();</span><br><span class="line">                long costTimeAsync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                if (timeoutMillis &lt; costTimeAsync) &#123;</span><br><span class="line">                    throw new RemotingTooMuchRequestException(&quot;sendMessage call timeout&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                this.sendMessageAsync(addr, brokerName, msg, timeoutMillis - costTimeAsync, request, sendCallback, topicPublishInfo, instance, retryTimesWhenSendFailed, times, context, producer);</span><br><span class="line">                return null;</span><br><span class="line">            case SYNC:</span><br><span class="line">                long costTimeSync = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                if (timeoutMillis &lt; costTimeSync) &#123;</span><br><span class="line">                    throw new RemotingTooMuchRequestException(&quot;sendMessage call timeout&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                return this.sendMessageSync(addr, brokerName, msg, timeoutMillis - costTimeSync, request);</span><br><span class="line">            default:</span><br><span class="line">                assert false;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<strong>同步消息</strong>最终用通过 <strong><code>RequestCode.SEND_MESSAGE</code></strong> 编号最终在 <strong><code>Broker</code></strong> 中执行 <strong><code>SendMessageProcessor</code></strong> 的 <strong><code>processRequest</code></strong> 方法,<strong>异步消息</strong>最终调用的是 <strong><code>SendMessageProcessor</code></strong> 的 <strong><code>asyncProcessRequest</code></strong> 方法,最终都是调用的 <strong><code>asyncProcessRequest</code></strong> 方法,不同点在于同步消息的 <strong><code>processRequest</code></strong> 中获取到异步 <strong><code>CompletableFuture</code></strong> 直接调用get方法等待结果,不论是同步还是异步方法最终都是在 <strong><code>handlePutMessageResultFuture</code></strong> 方法中调用 <strong><code>CompletableFuture</code></strong> 的 <strong><code>thenApply</code></strong> 方法,在响应后最终在 <strong><code>handlePutMessageResult</code></strong> 中调用 <strong><code>doResponse</code></strong> 方法将结果写回给客户端.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line">public class MQClientAPIImpl &#123;</span><br><span class="line">    private SendResult sendMessageSync(final String addr, final String brokerName, final Message msg, final long timeoutMillis, final RemotingCommand request) throws RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">        RemotingCommand response = this.remotingClient.invokeSync(addr, request, timeoutMillis);</span><br><span class="line">        assert response != null;</span><br><span class="line">        return this.processSendResponse(brokerName, msg, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class NettyRemotingClient extends NettyRemotingAbstract implements RemotingClient &#123;</span><br><span class="line">    public RemotingCommand invokeSync(String addr, final RemotingCommand request, long timeoutMillis) throws InterruptedException, RemotingConnectException, RemotingSendRequestException, RemotingTimeoutException &#123;</span><br><span class="line">        long beginStartTime = System.currentTimeMillis();</span><br><span class="line">        // channel是和Nameserver之间建立的一个连接.</span><br><span class="line">        final Channel channel = this.getAndCreateChannel(addr);</span><br><span class="line">        if (channel != null &amp;&amp; channel.isActive()) &#123; // 网络连接ok则发送请求</span><br><span class="line">            try &#123;</span><br><span class="line">                doBeforeRpcHooks(addr, request); //计算时间</span><br><span class="line">                long costTime = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                if (timeoutMillis &lt; costTime) &#123;</span><br><span class="line">                    throw new RemotingTimeoutException(&quot;invokeSync call timeout&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                RemotingCommand response = this.invokeSyncImpl(channel, request, timeoutMillis - costTime); // 真正发网络请求的地方</span><br><span class="line">                doAfterRpcHooks(RemotingHelper.parseChannelRemoteAddr(channel), request, response);</span><br><span class="line">                return response;</span><br><span class="line">            &#125; catch (RemotingSendRequestException e) &#123;</span><br><span class="line">                this.closeChannel(addr, channel);</span><br><span class="line">                throw e;</span><br><span class="line">            &#125; catch (RemotingTimeoutException e) &#123;</span><br><span class="line">                if (nettyClientConfig.isClientCloseSocketIfTimeout()) &#123;</span><br><span class="line">                    this.closeChannel(addr, channel);</span><br><span class="line">                &#125;</span><br><span class="line">                throw e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.closeChannel(addr, channel);</span><br><span class="line">            throw new RemotingConnectException(addr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class SendMessageProcessor extends AbstractSendMessageProcessor implements NettyRequestProcessor &#123;</span><br><span class="line">    public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException &#123;</span><br><span class="line">        RemotingCommand response = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            response = asyncProcessRequest(ctx, request).get();</span><br><span class="line">        &#125;</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line">    public CompletableFuture&lt;RemotingCommand&gt; asyncProcessRequest(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException &#123;</span><br><span class="line">        final SendMessageContext mqtraceContext;</span><br><span class="line">        switch (request.getCode()) &#123;</span><br><span class="line">            case RequestCode.CONSUMER_SEND_MSG_BACK:</span><br><span class="line">                return this.asyncConsumerSendMsgBack(ctx, request);</span><br><span class="line">            default:</span><br><span class="line">                SendMessageRequestHeader requestHeader = parseRequestHeader(request);</span><br><span class="line">                if (requestHeader == null) &#123;</span><br><span class="line">                    return CompletableFuture.completedFuture(null);</span><br><span class="line">                &#125;</span><br><span class="line">                mqtraceContext = buildMsgContext(ctx, requestHeader);</span><br><span class="line">                this.executeSendMessageHookBefore(ctx, request, mqtraceContext);</span><br><span class="line">                if (requestHeader.isBatch()) &#123;</span><br><span class="line">                    return this.asyncSendBatchMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    return this.asyncSendMessage(ctx, request, mqtraceContext, requestHeader);</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private CompletableFuture&lt;RemotingCommand&gt; asyncSendMessage(ChannelHandlerContext ctx, RemotingCommand request, SendMessageContext mqtraceContext, SendMessageRequestHeader requestHeader) &#123;</span><br><span class="line">        final RemotingCommand response = preSend(ctx, request, requestHeader);</span><br><span class="line">        final SendMessageResponseHeader responseHeader = (SendMessageResponseHeader)response.readCustomHeader();</span><br><span class="line">        if (response.getCode() != -1) &#123;</span><br><span class="line">            return CompletableFuture.completedFuture(response);</span><br><span class="line">        &#125;</span><br><span class="line">        final byte[] body = request.getBody();</span><br><span class="line">        int queueIdInt = requestHeader.getQueueId();</span><br><span class="line">        TopicConfig topicConfig = this.brokerController.getTopicConfigManager().selectTopicConfig(requestHeader.getTopic());</span><br><span class="line">        if (queueIdInt &lt; 0) &#123;</span><br><span class="line">            queueIdInt = randomQueueId(topicConfig.getWriteQueueNums());</span><br><span class="line">        &#125;</span><br><span class="line">        MessageExtBrokerInner msgInner = new MessageExtBrokerInner();</span><br><span class="line">        msgInner.setTopic(requestHeader.getTopic());</span><br><span class="line">        msgInner.setQueueId(queueIdInt);</span><br><span class="line">        if (!handleRetryAndDLQ(requestHeader, response, request, msgInner, topicConfig)) &#123;</span><br><span class="line">            return CompletableFuture.completedFuture(response);</span><br><span class="line">        &#125;</span><br><span class="line">        msgInner.setBody(body);</span><br><span class="line">        msgInner.setFlag(requestHeader.getFlag());</span><br><span class="line">        MessageAccessor.setProperties(msgInner, MessageDecoder.string2messageProperties(requestHeader.getProperties()));</span><br><span class="line">        msgInner.setPropertiesString(requestHeader.getProperties());</span><br><span class="line">        msgInner.setBornTimestamp(requestHeader.getBornTimestamp());</span><br><span class="line">        msgInner.setBornHost(ctx.channel().remoteAddress());</span><br><span class="line">        msgInner.setStoreHost(this.getStoreHost());</span><br><span class="line">        msgInner.setReconsumeTimes(requestHeader.getReconsumeTimes() == null ? 0 : requestHeader.getReconsumeTimes());</span><br><span class="line">        String clusterName = this.brokerController.getBrokerConfig().getBrokerClusterName();</span><br><span class="line">        MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_CLUSTER, clusterName);</span><br><span class="line">        msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));</span><br><span class="line">        CompletableFuture&lt;PutMessageResult&gt; putMessageResult = null;</span><br><span class="line">        Map&lt;String, String&gt; origProps = MessageDecoder.string2messageProperties(requestHeader.getProperties());</span><br><span class="line">        String transFlag = origProps.get(MessageConst.PROPERTY_TRANSACTION_PREPARED);</span><br><span class="line">        if (transFlag != null &amp;&amp; Boolean.parseBoolean(transFlag)) &#123;</span><br><span class="line">            if (this.brokerController.getBrokerConfig().isRejectTransactionMessage()) &#123;</span><br><span class="line">                response.setCode(ResponseCode.NO_PERMISSION);</span><br><span class="line">                response.setRemark(&quot;the broker[&quot; + this.brokerController.getBrokerConfig().getBrokerIP1() + &quot;] sending transaction message is forbidden&quot;);</span><br><span class="line">                return CompletableFuture.completedFuture(response);</span><br><span class="line">            &#125;</span><br><span class="line">            putMessageResult = this.brokerController.getTransactionalMessageService().asyncPrepareMessage(msgInner); // 事务消息持久化</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            putMessageResult = this.brokerController.getMessageStore().asyncPutMessage(msgInner); // 普通消息持久化</span><br><span class="line">        &#125;</span><br><span class="line">        return handlePutMessageResultFuture(putMessageResult, response, request, msgInner, responseHeader, mqtraceContext, ctx, queueIdInt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于异步方法当获取到响应后会回调 <strong><code>InvokeCallback</code></strong> 中的 <strong><code>operationComplete</code></strong> 方法,在该方法中若成功则回调用 <strong><code>SendCallback</code></strong> 的 <strong><code>onSuccess</code></strong> 方法.若失败则走重试逻辑若中还是失败则回调用 <strong><code>SendCallback</code></strong> 的 <strong><code>onException</code></strong> 方法.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">public class MQClientAPIImpl &#123;</span><br><span class="line">    private void sendMessageAsync(final String addr, final String brokerName, final Message msg, final long timeoutMillis, final RemotingCommand request, final SendCallback sendCallback, final TopicPublishInfo topicPublishInfo, final MQClientInstance instance,</span><br><span class="line">                                  final int retryTimesWhenSendFailed, final AtomicInteger times, final SendMessageContext context, final DefaultMQProducerImpl producer) throws InterruptedException, RemotingException &#123;</span><br><span class="line">        final long beginStartTime = System.currentTimeMillis();</span><br><span class="line">        this.remotingClient.invokeAsync(addr, request, timeoutMillis, new InvokeCallback() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void operationComplete(ResponseFuture responseFuture) &#123;</span><br><span class="line">                long cost = System.currentTimeMillis() - beginStartTime;</span><br><span class="line">                RemotingCommand response = responseFuture.getResponseCommand();</span><br><span class="line">                if (null == sendCallback &amp;&amp; response != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        SendResult sendResult = MQClientAPIImpl.this.processSendResponse(brokerName, msg, response);</span><br><span class="line">                        if (context != null &amp;&amp; sendResult != null) &#123;</span><br><span class="line">                            context.setSendResult(sendResult);</span><br><span class="line">                            context.getProducer().executeSendMessageHookAfter(context);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (Throwable e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                    producer.updateFaultItem(brokerName, System.currentTimeMillis() - responseFuture.getBeginTimestamp(), false);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line">                if (response != null) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        SendResult sendResult = MQClientAPIImpl.this.processSendResponse(brokerName, msg, response);</span><br><span class="line">                        assert sendResult != null;</span><br><span class="line">                        if (context != null) &#123;</span><br><span class="line">                            context.setSendResult(sendResult);</span><br><span class="line">                            context.getProducer().executeSendMessageHookAfter(context);</span><br><span class="line">                        &#125;</span><br><span class="line">                        try &#123;</span><br><span class="line">                            sendCallback.onSuccess(sendResult); // 回调用SendCallback的onSuccess方法</span><br><span class="line">                        &#125; catch (Throwable e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                        producer.updateFaultItem(brokerName, System.currentTimeMillis() - responseFuture.getBeginTimestamp(), false);</span><br><span class="line">                    &#125; catch (Exception e) &#123;</span><br><span class="line">                        producer.updateFaultItem(brokerName, System.currentTimeMillis() - responseFuture.getBeginTimestamp(), true);</span><br><span class="line">                        onExceptionImpl(brokerName, msg, timeoutMillis - cost, request, sendCallback, topicPublishInfo, instance, retryTimesWhenSendFailed, times, e, context, false, producer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    producer.updateFaultItem(brokerName, System.currentTimeMillis() - responseFuture.getBeginTimestamp(), true);</span><br><span class="line">                    if (!responseFuture.isSendRequestOK()) &#123;</span><br><span class="line">                        MQClientException ex = new MQClientException(&quot;send request failed&quot;, responseFuture.getCause());</span><br><span class="line">                        onExceptionImpl(brokerName, msg, timeoutMillis - cost, request, sendCallback, topicPublishInfo, instance, retryTimesWhenSendFailed, times, ex, context, true, producer);</span><br><span class="line">                    &#125; else if (responseFuture.isTimeout()) &#123;</span><br><span class="line">                        MQClientException ex = new MQClientException(&quot;wait response timeout &quot; + responseFuture.getTimeoutMillis() + &quot;ms&quot;, responseFuture.getCause());</span><br><span class="line">                        onExceptionImpl(brokerName, msg, timeoutMillis - cost, request, sendCallback, topicPublishInfo, instance, retryTimesWhenSendFailed, times, ex, context, true, producer);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        MQClientException ex = new MQClientException(&quot;unknow reseaon&quot;, responseFuture.getCause());</span><br><span class="line">                        onExceptionImpl(brokerName, msg, timeoutMillis - cost, request, sendCallback, topicPublishInfo, instance, retryTimesWhenSendFailed, times, ex, context, true, producer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h2><p>对于事务消息的发送是通过 <strong><code>TransactionMQProducer</code></strong> 类的 <strong><code>sendMessageInTransaction</code></strong> 方法来完成的,若<strong>事务消息设置了延迟参数则将会被清除</strong>,会设置 <strong><code>TRAN_MSG</code></strong> 属性为 <strong><code>true</code></strong> ,然后调用send方法发送消费到 <strong><code>Broker</code></strong> ,send方法中和普通的发送消息调用的一个方法,但普通消息是走的 <strong><code>DefaultMessageStore</code></strong> 的 <strong><code>asyncPutMessage</code></strong> 方法,<strong>事务消息</strong>是走的 <strong><code>TransactionalMessageServiceImpl</code></strong> 的 <strong><code>asyncPrepareMessage</code></strong> 方法.若发送成功则调用设置的 <strong><code>TransactionListener</code></strong> 的 <strong><code>executeLocalTransaction</code></strong> 方法,然后调用 <strong><code>MQClientAPIImpl</code></strong> 的 <strong><code>endTransactionOneway</code></strong> 方法.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionMQProducer extends DefaultMQProducer &#123;</span><br><span class="line">    public TransactionSendResult sendMessageInTransaction(final Message msg, final Object arg) throws MQClientException &#123;</span><br><span class="line">        if (null == this.transactionListener) &#123;</span><br><span class="line">            throw new MQClientException(&quot;TransactionListener is null&quot;, null);</span><br><span class="line">        &#125;</span><br><span class="line">        msg.setTopic(NamespaceUtil.wrapNamespace(this.getNamespace(), msg.getTopic()));</span><br><span class="line">        return this.defaultMQProducerImpl.sendMessageInTransaction(msg, null, arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DefaultMQProducerImpl implements MQProducerInner &#123;</span><br><span class="line">    public TransactionSendResult sendMessageInTransaction(final Message msg, final LocalTransactionExecuter localTransactionExecuter, final Object arg) throws MQClientException &#123;</span><br><span class="line">        TransactionListener transactionListener = getCheckListener();</span><br><span class="line">        if (null == localTransactionExecuter &amp;&amp; null == transactionListener) &#123;</span><br><span class="line">            throw new MQClientException(&quot;tranExecutor is null&quot;, null);</span><br><span class="line">        &#125;</span><br><span class="line">        if (msg.getDelayTimeLevel() != 0) &#123;  // 不支持延迟消息</span><br><span class="line">            MessageAccessor.clearProperty(msg, MessageConst.PROPERTY_DELAY_TIME_LEVEL);</span><br><span class="line">        &#125;</span><br><span class="line">        Validators.checkMessage(msg, this.defaultMQProducer);</span><br><span class="line">        SendResult sendResult = null;</span><br><span class="line">        MessageAccessor.putProperty(msg, MessageConst.PROPERTY_TRANSACTION_PREPARED, &quot;true&quot;);</span><br><span class="line">        MessageAccessor.putProperty(msg, MessageConst.PROPERTY_PRODUCER_GROUP, this.defaultMQProducer.getProducerGroup());</span><br><span class="line">        try &#123;</span><br><span class="line">            sendResult = this.send(msg);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            throw new MQClientException(&quot;send message Exception&quot;, e);</span><br><span class="line">        &#125;</span><br><span class="line">        LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW; // 默认本地事务状态为UNKNOW</span><br><span class="line">        Throwable localException = null;</span><br><span class="line">        switch (sendResult.getSendStatus()) &#123;</span><br><span class="line">            case SEND_OK: &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (sendResult.getTransactionId() != null) &#123;</span><br><span class="line">                        msg.putUserProperty(&quot;__transactionId__&quot;, sendResult.getTransactionId());</span><br><span class="line">                    &#125;</span><br><span class="line">                    String transactionId = msg.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</span><br><span class="line">                    if (null != transactionId &amp;&amp; !&quot;&quot;.equals(transactionId)) &#123;</span><br><span class="line">                        msg.setTransactionId(transactionId);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (null != localTransactionExecuter) &#123; // 默认localTransactionExecuter为null</span><br><span class="line">                        localTransactionState = localTransactionExecuter.executeLocalTransactionBranch(msg, arg);</span><br><span class="line">                    &#125; else if (transactionListener != null) &#123; // transactionListener是调用时设置的</span><br><span class="line">                        localTransactionState = transactionListener.executeLocalTransaction(msg, arg);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (null == localTransactionState) &#123;</span><br><span class="line">                        localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (Throwable e) &#123;</span><br><span class="line">                    localException = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">                break;</span><br><span class="line">            case FLUSH_DISK_TIMEOUT:</span><br><span class="line">            case FLUSH_SLAVE_TIMEOUT:</span><br><span class="line">            case SLAVE_NOT_AVAILABLE:</span><br><span class="line">                localTransactionState = LocalTransactionState.ROLLBACK_MESSAGE;</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        try &#123;</span><br><span class="line">            this.endTransaction(sendResult, localTransactionState, localException);</span><br><span class="line">        &#125;</span><br><span class="line">        TransactionSendResult transactionSendResult = new TransactionSendResult();</span><br><span class="line">        transactionSendResult.setSendStatus(sendResult.getSendStatus());</span><br><span class="line">        transactionSendResult.setMessageQueue(sendResult.getMessageQueue());</span><br><span class="line">        transactionSendResult.setMsgId(sendResult.getMsgId());</span><br><span class="line">        transactionSendResult.setQueueOffset(sendResult.getQueueOffset());</span><br><span class="line">        transactionSendResult.setTransactionId(sendResult.getTransactionId());</span><br><span class="line">        transactionSendResult.setLocalTransactionState(localTransactionState);</span><br><span class="line">        return transactionSendResult;</span><br><span class="line">    &#125;</span><br><span class="line">    public void endTransaction(final SendResult sendResult, final LocalTransactionState localTransactionState, final Throwable localException) throws RemotingException, MQBrokerException, InterruptedException, UnknownHostException &#123;</span><br><span class="line">        final MessageId id;</span><br><span class="line">        if (sendResult.getOffsetMsgId() != null) &#123;</span><br><span class="line">            id = MessageDecoder.decodeMessageId(sendResult.getOffsetMsgId());</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            id = MessageDecoder.decodeMessageId(sendResult.getMsgId());</span><br><span class="line">        &#125;</span><br><span class="line">        String transactionId = sendResult.getTransactionId();</span><br><span class="line">        final String brokerAddr = this.mQClientFactory.findBrokerAddressInPublish(sendResult.getMessageQueue().getBrokerName());</span><br><span class="line">        EndTransactionRequestHeader requestHeader = new EndTransactionRequestHeader();</span><br><span class="line">        requestHeader.setTransactionId(transactionId);</span><br><span class="line">        requestHeader.setCommitLogOffset(id.getOffset());</span><br><span class="line">        switch (localTransactionState) &#123;</span><br><span class="line">            case COMMIT_MESSAGE:</span><br><span class="line">                requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</span><br><span class="line">                break;</span><br><span class="line">            case ROLLBACK_MESSAGE:</span><br><span class="line">                requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</span><br><span class="line">                break;</span><br><span class="line">            case UNKNOW:</span><br><span class="line">                requestHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</span><br><span class="line">                break;</span><br><span class="line">            default:</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        requestHeader.setProducerGroup(this.defaultMQProducer.getProducerGroup());</span><br><span class="line">        requestHeader.setTranStateTableOffset(sendResult.getQueueOffset());</span><br><span class="line">        requestHeader.setMsgId(sendResult.getMsgId());</span><br><span class="line">        String remark = localException != null ? (&quot;executeLocalTransactionBranch exception: &quot; + localException.toString()) : null;</span><br><span class="line">        this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, requestHeader, remark, this.defaultMQProducer.getSendMsgTimeout());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class MQClientAPIImpl &#123;</span><br><span class="line">    public void endTransactionOneway(final String addr, final EndTransactionRequestHeader requestHeader, final String remark, final long timeoutMillis) throws RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.END_TRANSACTION, requestHeader);</span><br><span class="line">        request.setRemark(remark);</span><br><span class="line">        this.remotingClient.invokeOneway(addr, request, timeoutMillis);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先会将将真正的事务 <strong><code>Topic</code></strong> 存储到 <strong><code>REAL_TOPIC</code></strong> 属性中,然后将 <strong><code>Topic</code></strong> 换成 <strong><code>RMQ_SYS_TRANS_HALF_TOPIC</code></strong> ,然后将替换了Topic的事务消息通过 <strong><code>DefaultMessageStore</code></strong> 的 <strong><code>asyncPutMessage</code></strong> 方法最终存储到 <strong><code>CommitLog</code></strong> 中.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionalMessageServiceImpl implements TransactionalMessageService &#123;</span><br><span class="line">    public CompletableFuture&lt;PutMessageResult&gt; asyncPrepareMessage(MessageExtBrokerInner messageInner) &#123;</span><br><span class="line">        return transactionalMessageBridge.asyncPutHalfMessage(messageInner);</span><br><span class="line">    &#125;</span><br><span class="line">    public CompletableFuture&lt;PutMessageResult&gt; asyncPutHalfMessage(MessageExtBrokerInner messageInner) &#123;</span><br><span class="line">        return store.asyncPutMessage(parseHalfMessageInner(messageInner));</span><br><span class="line">    &#125;</span><br><span class="line">    private MessageExtBrokerInner parseHalfMessageInner(MessageExtBrokerInner msgInner) &#123;</span><br><span class="line">        MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_TOPIC, msgInner.getTopic()); // 将真正的事务Topic存储到REAL_TOPIC属性中</span><br><span class="line">        MessageAccessor.putProperty(msgInner, MessageConst.PROPERTY_REAL_QUEUE_ID, String.valueOf(msgInner.getQueueId()));</span><br><span class="line">        msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), MessageSysFlag.TRANSACTION_NOT_TYPE));</span><br><span class="line">        msgInner.setTopic(TransactionalMessageUtil.buildHalfTopic()); // Topic换成RMQ_SYS_TRANS_HALF_TOPIC</span><br><span class="line">        msgInner.setQueueId(0);</span><br><span class="line">        msgInner.setPropertiesString(MessageDecoder.messageProperties2String(msgInner.getProperties()));</span><br><span class="line">        return msgInner;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终通过 <strong><code>RequestCode.END_TRANSACTION</code></strong> 编码关联调用 <strong><code>EndTransactionProcessor</code></strong> 的 <strong><code>processRequest</code></strong> 方法,不论是是 <strong><code>COMMIT</code></strong> 还是 <strong><code>ROLLBACK</code></strong> 都将消息从 <strong><code>RMQ_SYS_TRANS_HALF_TOPIC</code></strong> 队列中查询出,若是 <strong><code>COMMIT</code></strong> 则将从 <strong><code>RMQ_SYS_TRANS_HALF_TOPIC</code></strong> 队列中查询的消息真正存储到其<strong>真实的<code>Topic</code>队列中</strong>,然后成功则再在 <strong><code>RMQ_SYS_TRANS_OP_HALF_TOPIC</code></strong> 队列中添加一条对应的消息<strong>标识该<code>Half</code>消息被删除</strong>.若为 <strong><code>ROLLBACK</code></strong> 则直接在 <strong><code>RMQ_SYS_TRANS_OP_HALF_TOPIC</code></strong> 队列中添加一条对应的消<strong>标识事务结束</strong>.开源版本进行了阉割,不会走回查逻辑.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">public class EndTransactionProcessor extends AsyncNettyRequestProcessor implements NettyRequestProcessor &#123;</span><br><span class="line">    public RemotingCommand processRequest(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException &#123;</span><br><span class="line">        final RemotingCommand response = RemotingCommand.createResponseCommand(null);</span><br><span class="line">        final EndTransactionRequestHeader requestHeader = (EndTransactionRequestHeader)request.decodeCommandCustomHeader(EndTransactionRequestHeader.class);</span><br><span class="line">        if (BrokerRole.SLAVE == brokerController.getMessageStoreConfig().getBrokerRole()) &#123;</span><br><span class="line">            response.setCode(ResponseCode.SLAVE_NOT_AVAILABLE);</span><br><span class="line">            return response; // 若当前节点是从节点</span><br><span class="line">        &#125;</span><br><span class="line">        OperationResult result = new OperationResult();</span><br><span class="line">        if (MessageSysFlag.TRANSACTION_COMMIT_TYPE == requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">            result = this.brokerController.getTransactionalMessageService().commitMessage(requestHeader);</span><br><span class="line">            if (result.getResponseCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);</span><br><span class="line">                if (res.getCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                    MessageExtBrokerInner msgInner = endMessageTransaction(result.getPrepareMessage());</span><br><span class="line">                    msgInner.setSysFlag(MessageSysFlag.resetTransactionValue(msgInner.getSysFlag(), requestHeader.getCommitOrRollback()));</span><br><span class="line">                    msgInner.setQueueOffset(requestHeader.getTranStateTableOffset());</span><br><span class="line">                    msgInner.setPreparedTransactionOffset(requestHeader.getCommitLogOffset());</span><br><span class="line">                    msgInner.setStoreTimestamp(result.getPrepareMessage().getStoreTimestamp());</span><br><span class="line">                    MessageAccessor.clearProperty(msgInner, MessageConst.PROPERTY_TRANSACTION_PREPARED); // 将事务消息TRAN_MSG标记移除</span><br><span class="line">                    RemotingCommand sendResult = sendFinalMessage(msgInner);// 将从RMQ_SYS_TRANS_HALF_TOPIC队列中查询的消息真正存储到其真实的Topic队列中</span><br><span class="line">                    if (sendResult.getCode() == ResponseCode.SUCCESS) &#123;// 存储成功则在RMQ_SYS_TRANS_OP_HALF_TOPIC队列中添加对应的消息</span><br><span class="line">                        this.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                    return sendResult;</span><br><span class="line">                &#125;</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (MessageSysFlag.TRANSACTION_ROLLBACK_TYPE == requestHeader.getCommitOrRollback()) &#123;</span><br><span class="line">            result = this.brokerController.getTransactionalMessageService().rollbackMessage(requestHeader);</span><br><span class="line">            if (result.getResponseCode() == ResponseCode.SUCCESS) &#123;</span><br><span class="line">                RemotingCommand res = checkPrepareMessage(result.getPrepareMessage(), requestHeader);</span><br><span class="line">                if (res.getCode() == ResponseCode.SUCCESS) &#123;// 成功则在RMQ_SYS_TRANS_OP_HALF_TOPIC队列中添加对应的消息</span><br><span class="line">                    this.brokerController.getTransactionalMessageService().deletePrepareMessage(result.getPrepareMessage());</span><br><span class="line">                &#125;</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        response.setCode(result.getResponseCode());</span><br><span class="line">        response.setRemark(result.getResponseRemark());</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TransactionalMessageServiceImpl implements TransactionalMessageService &#123;</span><br><span class="line">    public OperationResult commitMessage(EndTransactionRequestHeader requestHeader) &#123;</span><br><span class="line">        return getHalfMessageByOffset(requestHeader.getCommitLogOffset());</span><br><span class="line">    &#125;</span><br><span class="line">    public OperationResult rollbackMessage(EndTransactionRequestHeader requestHeader) &#123;</span><br><span class="line">        return getHalfMessageByOffset(requestHeader.getCommitLogOffset());</span><br><span class="line">    &#125;</span><br><span class="line">    private OperationResult getHalfMessageByOffset(long commitLogOffset) &#123;</span><br><span class="line">        OperationResult response = new OperationResult();</span><br><span class="line">        MessageExt messageExt = this.transactionalMessageBridge.lookMessageByOffset(commitLogOffset);</span><br><span class="line">        if (messageExt != null) &#123;</span><br><span class="line">            response.setPrepareMessage(messageExt);</span><br><span class="line">            response.setResponseCode(ResponseCode.SUCCESS);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            response.setResponseCode(ResponseCode.SYSTEM_ERROR);</span><br><span class="line">            response.setResponseRemark(&quot;Find prepared transaction message failed&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        return response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <strong><code>BrokerController</code></strong> 的 <strong><code>initialTransaction()</code></strong> 方法中会初始化<strong>事务消息检查类<code>TransactionalMessageCheckService</code></strong> ,该类是一个线程类,在 <strong><code>BrokerController</code></strong> 的 <strong><code>start</code></strong> 方法中通过 <strong><code>startProcessorByHa</code></strong> 方法<strong>开启事务消息检查线程</strong>.若已经超过最大回查次数,则将消息添加到 <strong><code>TRANS_CHECK_MAXTIME_TOPIC</code></strong> 队列中,若需要检查则将消息写回 <strong><code>RMQ_SYS_TRANS_HALF_TOPIC</code></strong> 队列中防止再次失败,然后调用 <strong><code>AbstractTransactionalMessageCheckListener</code></strong> 的 <strong><code>resolveHalfMsg</code></strong> 方法检查消息.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line">public class TransactionalMessageCheckService extends ServiceThread &#123;</span><br><span class="line">    public void run() &#123; // 默认60s</span><br><span class="line">        long checkInterval = brokerController.getBrokerConfig().getTransactionCheckInterval();</span><br><span class="line">        while (!this.isStopped()) &#123;</span><br><span class="line">            this.waitForRunning(checkInterval);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    protected void waitForRunning(long interval) &#123;</span><br><span class="line">        if (hasNotified.compareAndSet(true, false)) &#123;</span><br><span class="line">            this.onWaitEnd();</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        waitPoint.reset();</span><br><span class="line">        try &#123;</span><br><span class="line">            waitPoint.await(interval, TimeUnit.MILLISECONDS);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            hasNotified.set(false);</span><br><span class="line">            this.onWaitEnd();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    protected void onWaitEnd() &#123;</span><br><span class="line">        long timeout = brokerController.getBrokerConfig().getTransactionTimeOut(); // 获取超时时间6s</span><br><span class="line">        int checkMax = brokerController.getBrokerConfig().getTransactionCheckMax();  // 获取最大回查次数15</span><br><span class="line">        long begin = System.currentTimeMillis();</span><br><span class="line">        this.brokerController.getTransactionalMessageService().check(timeout, checkMax, this.brokerController.getTransactionalMessageCheckListener());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class TransactionalMessageServiceImpl implements TransactionalMessageService &#123;</span><br><span class="line">    public void check(long transactionTimeout, int transactionCheckMax, AbstractTransactionalMessageCheckListener listener) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            String topic = TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC;  // RMQ_SYS_TRANS_HALF_TOPIC</span><br><span class="line">            Set&lt;MessageQueue&gt; msgQueues = transactionalMessageBridge.fetchMessageQueues(topic);</span><br><span class="line">            if (msgQueues == null || msgQueues.size() == 0) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            for (MessageQueue messageQueue : msgQueues) &#123;</span><br><span class="line">                long startTime = System.currentTimeMillis();</span><br><span class="line">                MessageQueue opQueue = getOpQueue(messageQueue);</span><br><span class="line">                long halfOffset = transactionalMessageBridge.fetchConsumeOffset(messageQueue);</span><br><span class="line">                long opOffset = transactionalMessageBridge.fetchConsumeOffset(opQueue);</span><br><span class="line">                if (halfOffset &lt; 0 || opOffset &lt; 0) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;Long&gt; doneOpOffset = new ArrayList&lt;&gt;();</span><br><span class="line">                HashMap&lt;Long, Long&gt; removeMap = new HashMap&lt;&gt;();</span><br><span class="line">                PullResult pullResult = fillOpRemoveMap(removeMap, opQueue, opOffset, halfOffset, doneOpOffset);</span><br><span class="line">                if (null == pullResult) &#123;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                int getMessageNullCount = 1;</span><br><span class="line">                long newOffset = halfOffset;</span><br><span class="line">                long i = halfOffset;</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    if (System.currentTimeMillis() - startTime &gt; MAX_PROCESS_TIME_LIMIT) &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (removeMap.containsKey(i)) &#123;</span><br><span class="line">                        Long removedOpOffset = removeMap.remove(i);</span><br><span class="line">                        doneOpOffset.add(removedOpOffset);</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        GetResult getResult = getHalfMsg(messageQueue, i); // 消费RMQ_SYS_TRANS_HALF_TOPIC队列中的事务消息</span><br><span class="line">                        MessageExt msgExt = getResult.getMsg();</span><br><span class="line">                        if (msgExt == null) &#123;</span><br><span class="line">                            if (getMessageNullCount++ &gt; MAX_RETRY_COUNT_WHEN_HALF_NULL) &#123;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                            if (getResult.getPullResult().getPullStatus() == PullStatus.NO_NEW_MSG) &#123;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125; else &#123;</span><br><span class="line">                                i = getResult.getPullResult().getNextBeginOffset();</span><br><span class="line">                                newOffset = i;</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (needDiscard(msgExt, transactionCheckMax) || needSkip(msgExt)) &#123;// 若已经超过最大回查次数了</span><br><span class="line">                            listener.resolveDiscardMsg(msgExt); // 将消息添加到TRANS_CHECK_MAXTIME_TOPIC队列中</span><br><span class="line">                            newOffset = i + 1;</span><br><span class="line">                            i++;</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                        if (msgExt.getStoreTimestamp() &gt;= startTime) &#123;</span><br><span class="line">                            break;</span><br><span class="line">                        &#125;</span><br><span class="line">                        long valueOfCurrentMinusBorn = System.currentTimeMillis() - msgExt.getBornTimestamp();</span><br><span class="line">                        long checkImmunityTime = transactionTimeout;</span><br><span class="line">                        String checkImmunityTimeStr = msgExt.getUserProperty(MessageConst.PROPERTY_CHECK_IMMUNITY_TIME_IN_SECONDS);</span><br><span class="line">                        if (null != checkImmunityTimeStr) &#123;</span><br><span class="line">                            checkImmunityTime = getImmunityTime(checkImmunityTimeStr, transactionTimeout);</span><br><span class="line">                            if (valueOfCurrentMinusBorn &lt; checkImmunityTime) &#123;</span><br><span class="line">                                if (checkPrepareQueueOffset(removeMap, doneOpOffset, msgExt)) &#123;</span><br><span class="line">                                    newOffset = i + 1;</span><br><span class="line">                                    i++;</span><br><span class="line">                                    continue;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            if ((0 &lt;= valueOfCurrentMinusBorn) &amp;&amp; (valueOfCurrentMinusBorn &lt; checkImmunityTime)) &#123;</span><br><span class="line">                                break;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        List&lt;MessageExt&gt; opMsg = pullResult.getMsgFoundList();</span><br><span class="line">                        boolean isNeedCheck = (opMsg == null &amp;&amp; valueOfCurrentMinusBorn &gt; checkImmunityTime)</span><br><span class="line">                            || (opMsg != null &amp;&amp; (opMsg.get(opMsg.size() - 1).getBornTimestamp() - startTime &gt; transactionTimeout))</span><br><span class="line">                            || (valueOfCurrentMinusBorn &lt;= -1);</span><br><span class="line"></span><br><span class="line">                        if (isNeedCheck) &#123;</span><br><span class="line">                            if (!putBackHalfMsgQueue(msgExt, i)) &#123; // 写回RMQ_SYS_TRANS_HALF_TOPIC队列中</span><br><span class="line">                                continue;</span><br><span class="line">                            &#125;</span><br><span class="line">                            listener.resolveHalfMsg(msgExt); // 真正检查消息的地方,回调客户端checkLocalTransaction方法</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            pullResult = fillOpRemoveMap(removeMap, opQueue, pullResult.getNextBeginOffset(), halfOffset, doneOpOffset);</span><br><span class="line">                            continue;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    newOffset = i + 1;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                if (newOffset != halfOffset) &#123;</span><br><span class="line">                    transactionalMessageBridge.updateConsumeOffset(messageQueue, newOffset);</span><br><span class="line">                &#125;</span><br><span class="line">                long newOpOffset = calculateOpOffset(doneOpOffset, opOffset);</span><br><span class="line">                if (newOpOffset != opOffset) &#123;</span><br><span class="line">                    transactionalMessageBridge.updateConsumeOffset(opQueue, newOpOffset);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查消息是异步执行的,首先还原当前消息真正的Topic,然后通过 <strong><code>Broker2Client</code></strong> 的 <strong><code>checkProducerTransactionState</code></strong> 方法中通过 <strong><code>RequestCode.CHECK_TRANSACTION_STATE</code></strong> 关联调用 <strong><code>ClientRemotingProcessor</code></strong> 的 <strong><code>ClientRemotingProcessor</code></strong> 方法.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">public abstract class AbstractTransactionalMessageCheckListener &#123;</span><br><span class="line">    public void resolveHalfMsg(final MessageExt msgExt) &#123;</span><br><span class="line">        executorService.execute(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    sendCheckMessage(msgExt);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void sendCheckMessage(MessageExt msgExt) throws Exception &#123;</span><br><span class="line">        CheckTransactionStateRequestHeader checkTransactionStateRequestHeader = new CheckTransactionStateRequestHeader();</span><br><span class="line">        checkTransactionStateRequestHeader.setCommitLogOffset(msgExt.getCommitLogOffset());</span><br><span class="line">        checkTransactionStateRequestHeader.setOffsetMsgId(msgExt.getMsgId());</span><br><span class="line">        checkTransactionStateRequestHeader.setMsgId(msgExt.getUserProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX));</span><br><span class="line">        checkTransactionStateRequestHeader.setTransactionId(checkTransactionStateRequestHeader.getMsgId());</span><br><span class="line">        checkTransactionStateRequestHeader.setTranStateTableOffset(msgExt.getQueueOffset());</span><br><span class="line">        msgExt.setTopic(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_TOPIC)); // 真正的Topic</span><br><span class="line">        msgExt.setQueueId(Integer.parseInt(msgExt.getUserProperty(MessageConst.PROPERTY_REAL_QUEUE_ID)));</span><br><span class="line">        msgExt.setStoreSize(0);</span><br><span class="line">        String groupId = msgExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP);</span><br><span class="line">        Channel channel = brokerController.getProducerManager().getAvaliableChannel(groupId);</span><br><span class="line">        if (channel != null) &#123;</span><br><span class="line">            brokerController.getBroker2Client().checkProducerTransactionState(groupId, channel, checkTransactionStateRequestHeader, msgExt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Broker2Client &#123;</span><br><span class="line">    public void checkProducerTransactionState(final String group, final Channel channel, final CheckTransactionStateRequestHeader requestHeader, final MessageExt messageExt) throws Exception &#123;</span><br><span class="line">        RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.CHECK_TRANSACTION_STATE, requestHeader);</span><br><span class="line">        request.setBody(MessageDecoder.encode(messageExt, false));</span><br><span class="line">        try &#123;</span><br><span class="line">            this.brokerController.getRemotingServer().invokeOneway(channel, request, 10);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先调用自定义 <strong><code>TransactionListener</code></strong> 的 <strong><code>checkLocalTransaction</code></strong> 方法,然后调用 <strong><code>MQClientAPIImpl</code></strong> 的 <strong><code>endTransactionOneway</code></strong> 方法.最终又调用 <strong><code>EndTransactionProcessor</code></strong> 的 <strong><code>processRequest</code></strong> 方法.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">public class ClientRemotingProcessor extends AsyncNettyRequestProcessor implements NettyRequestProcessor &#123;</span><br><span class="line">    public class ClientRemotingProcessor extends AsyncNettyRequestProcessor implements NettyRequestProcessor &#123;</span><br><span class="line">        public RemotingCommand checkTransactionState(ChannelHandlerContext ctx, RemotingCommand request) throws RemotingCommandException &#123;</span><br><span class="line">            final CheckTransactionStateRequestHeader requestHeader = (CheckTransactionStateRequestHeader) request.decodeCommandCustomHeader(CheckTransactionStateRequestHeader.class);</span><br><span class="line">            final ByteBuffer byteBuffer = ByteBuffer.wrap(request.getBody());</span><br><span class="line">            final MessageExt messageExt = MessageDecoder.decode(byteBuffer);</span><br><span class="line">            if (messageExt != null) &#123;</span><br><span class="line">                if (StringUtils.isNotEmpty(this.mqClientFactory.getClientConfig().getNamespace())) &#123;</span><br><span class="line">                    messageExt.setTopic(NamespaceUtil.withoutNamespace(messageExt.getTopic(), this.mqClientFactory.getClientConfig().getNamespace()));</span><br><span class="line">                &#125;</span><br><span class="line">                String transactionId = messageExt.getProperty(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</span><br><span class="line">                if (null != transactionId &amp;&amp; !&quot;&quot;.equals(transactionId)) &#123;</span><br><span class="line">                    messageExt.setTransactionId(transactionId);</span><br><span class="line">                &#125;</span><br><span class="line">                final String group = messageExt.getProperty(MessageConst.PROPERTY_PRODUCER_GROUP);</span><br><span class="line">                if (group != null) &#123;</span><br><span class="line">                    MQProducerInner producer = this.mqClientFactory.selectProducer(group);</span><br><span class="line">                    if (producer != null) &#123;</span><br><span class="line">                        final String addr = RemotingHelper.parseChannelRemoteAddr(ctx.channel());</span><br><span class="line">                        producer.checkTransactionState(addr, messageExt, requestHeader);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class DefaultMQProducerImpl implements MQProducerInner &#123;</span><br><span class="line">    public void checkTransactionState(final String addr, final MessageExt msg, final CheckTransactionStateRequestHeader header) &#123;</span><br><span class="line">        Runnable request = new Runnable() &#123;</span><br><span class="line">            private final String brokerAddr = addr;</span><br><span class="line">            private final MessageExt message = msg;</span><br><span class="line">            private final CheckTransactionStateRequestHeader checkRequestHeader = header;</span><br><span class="line">            private final String group = DefaultMQProducerImpl.this.defaultMQProducer.getProducerGroup();</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                TransactionCheckListener transactionCheckListener = DefaultMQProducerImpl.this.checkListener();</span><br><span class="line">                TransactionListener transactionListener = getCheckListener();</span><br><span class="line">                if (transactionCheckListener != null || transactionListener != null) &#123;</span><br><span class="line">                    LocalTransactionState localTransactionState = LocalTransactionState.UNKNOW;</span><br><span class="line">                    Throwable exception = null;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        if (transactionCheckListener != null) &#123;</span><br><span class="line">                            localTransactionState = transactionCheckListener.checkLocalTransactionState(message);</span><br><span class="line">                        &#125; else if (transactionListener != null) &#123;</span><br><span class="line">                            localTransactionState = transactionListener.checkLocalTransaction(message);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; catch (Throwable e) &#123;</span><br><span class="line">                        exception = e;</span><br><span class="line">                    &#125;</span><br><span class="line">                    this.processTransactionState(localTransactionState, group, exception);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            private void processTransactionState(final LocalTransactionState localTransactionState, final String producerGroup, final Throwable exception) &#123;</span><br><span class="line">                final EndTransactionRequestHeader thisHeader = new EndTransactionRequestHeader();</span><br><span class="line">                thisHeader.setCommitLogOffset(checkRequestHeader.getCommitLogOffset());</span><br><span class="line">                thisHeader.setProducerGroup(producerGroup);</span><br><span class="line">                thisHeader.setTranStateTableOffset(checkRequestHeader.getTranStateTableOffset());</span><br><span class="line">                thisHeader.setFromTransactionCheck(true);</span><br><span class="line">                String uniqueKey = message.getProperties().get(MessageConst.PROPERTY_UNIQ_CLIENT_MESSAGE_ID_KEYIDX);</span><br><span class="line">                if (uniqueKey == null) &#123;</span><br><span class="line">                    uniqueKey = message.getMsgId();</span><br><span class="line">                &#125;</span><br><span class="line">                thisHeader.setMsgId(uniqueKey);</span><br><span class="line">                thisHeader.setTransactionId(checkRequestHeader.getTransactionId());</span><br><span class="line">                switch (localTransactionState) &#123;</span><br><span class="line">                    case COMMIT_MESSAGE:</span><br><span class="line">                        thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_COMMIT_TYPE);</span><br><span class="line">                        break;</span><br><span class="line">                    case ROLLBACK_MESSAGE:</span><br><span class="line">                        thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_ROLLBACK_TYPE);</span><br><span class="line">                        break;</span><br><span class="line">                    case UNKNOW:</span><br><span class="line">                        thisHeader.setCommitOrRollback(MessageSysFlag.TRANSACTION_NOT_TYPE);</span><br><span class="line">                        break;</span><br><span class="line">                    default:</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line">                String remark = null;</span><br><span class="line">                if (exception != null) &#123;</span><br><span class="line">                    remark = &quot;checkLocalTransactionState Exception: &quot; + RemotingHelper.exceptionSimpleDesc(exception);</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    DefaultMQProducerImpl.this.mQClientFactory.getMQClientAPIImpl().endTransactionOneway(brokerAddr, thisHeader, remark, 3000);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        this.checkExecutor.submit(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public void endTransactionOneway(final String addr, final EndTransactionRequestHeader requestHeader, final String remark, final long timeoutMillis) throws RemotingException, MQBrokerException, InterruptedException &#123;</span><br><span class="line">    RemotingCommand request = RemotingCommand.createRequestCommand(RequestCode.END_TRANSACTION, requestHeader);</span><br><span class="line">    request.setRemark(remark);</span><br><span class="line">    this.remotingClient.invokeOneway(addr, request, timeoutMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="延迟消息"><a href="#延迟消息" class="headerlink" title="延迟消息"></a>延迟消息</h2><p><img src="/../../../../assets/png/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/%E5%BB%B6%E8%BF%9F%E6%B6%88%E6%81%AF.png" alt="延迟消息"></p>
<p>延迟消息写入时会将<strong>延迟消息转为写入到<code>SCHEDULE_TOPIC_XXXX</code>的Topic中</strong>,系统内置的该Topic有 <strong><code>18</code></strong> 个队列,对应18个延迟级别. <strong><code>ScheduleMessageService</code></strong> 会<strong>每隔<code>1s</code></strong> 执行一次 <strong><code>DeliverDelayedMessageTimerTask.executeOnTimeup</code></strong> 任务,将消息从延迟队列中写入正常Topic中.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line">public class ScheduleMessageService extends ConfigManager &#123;</span><br><span class="line">    private static final long FIRST_DELAY_TIME = 1000L;</span><br><span class="line">    private static final long DELAY_FOR_A_WHILE = 100L;</span><br><span class="line">    private static final long DELAY_FOR_A_PERIOD = 10000L;</span><br><span class="line">    public void start() &#123; // 延迟消息服务的启动方法</span><br><span class="line">        if (started.compareAndSet(false, true)) &#123;</span><br><span class="line">            this.timer = new Timer(&quot;ScheduleMessageTimerThread&quot;, true);</span><br><span class="line">            for (Map.Entry&lt;Integer, Long&gt; entry : this.delayLevelTable.entrySet()) &#123;</span><br><span class="line">                Integer level = entry.getKey();</span><br><span class="line">                Long timeDelay = entry.getValue();</span><br><span class="line">                Long offset = this.offsetTable.get(level);</span><br><span class="line">                if (null == offset) &#123;</span><br><span class="line">                    offset = 0L;</span><br><span class="line">                &#125;</span><br><span class="line">                if (timeDelay != null) &#123;//定时执行延迟消息处理任务</span><br><span class="line">                    this.timer.schedule(new DeliverDelayedMessageTimerTask(level, offset), FIRST_DELAY_TIME);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            this.timer.scheduleAtFixedRate(new TimerTask() &#123; //每隔10秒,将延迟消息持久化到硬盘中.</span><br><span class="line">                @Override public void run() &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        if (started.get()) ScheduleMessageService.this.persist();</span><br><span class="line">                    &#125; catch (Throwable e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;, 10000, this.defaultMessageStore.getMessageStoreConfig().getFlushDelayOffsetInterval());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">class DeliverDelayedMessageTimerTask extends TimerTask &#123;</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (isStarted()) &#123;</span><br><span class="line">                this.executeOnTimeup();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, this.offset), DELAY_FOR_A_PERIOD);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void executeOnTimeup() &#123;</span><br><span class="line">        // 拿到延迟级别对应的队列</span><br><span class="line">        ConsumeQueue cq = ScheduleMessageService.this.defaultMessageStore.findConsumeQueue(TopicValidator.RMQ_SYS_SCHEDULE_TOPIC, delayLevel2QueueId(delayLevel));</span><br><span class="line">        long failScheduleOffset = offset;</span><br><span class="line">        if (cq != null) &#123;</span><br><span class="line">            SelectMappedBufferResult bufferCQ = cq.getIndexBuffer(this.offset);</span><br><span class="line">            if (bufferCQ != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    long nextOffset = offset;</span><br><span class="line">                    int i = 0;</span><br><span class="line">                    ConsumeQueueExt.CqExtUnit cqExtUnit = new ConsumeQueueExt.CqExtUnit();</span><br><span class="line">                    // 遍历每个延迟队列的消息</span><br><span class="line">                    for (; i &lt; bufferCQ.getSize(); i += ConsumeQueue.CQ_STORE_UNIT_SIZE) &#123;</span><br><span class="line">                        long offsetPy = bufferCQ.getByteBuffer().getLong();</span><br><span class="line">                        int sizePy = bufferCQ.getByteBuffer().getInt();</span><br><span class="line">                        long tagsCode = bufferCQ.getByteBuffer().getLong();</span><br><span class="line">                        if (cq.isExtAddr(tagsCode)) &#123;</span><br><span class="line">                            if (cq.getExt(tagsCode, cqExtUnit)) &#123;</span><br><span class="line">                                tagsCode = cqExtUnit.getTagsCode();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        long now = System.currentTimeMillis();</span><br><span class="line">                        long deliverTimestamp = this.correctDeliverTimestamp(now, tagsCode);</span><br><span class="line">                        nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">                        long countdown = deliverTimestamp - now;</span><br><span class="line">                        if (countdown &lt;= 0) &#123; //把每个延迟消息封装成一个MessageExt</span><br><span class="line">                            MessageExt msgExt = ScheduleMessageService.this.defaultMessageStore.lookMessageByOffset(offsetPy, sizePy);</span><br><span class="line">                            if (msgExt != null) &#123;</span><br><span class="line">                                try &#123;</span><br><span class="line">                                    MessageExtBrokerInner msgInner = this.messageTimeup(msgExt);</span><br><span class="line">                                    if (TopicValidator.RMQ_SYS_TRANS_HALF_TOPIC.equals(msgInner.getTopic())) &#123;</span><br><span class="line">                                        continue;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    //将延迟消息写入正常消息队列,这样就能被消费者正常消费了.</span><br><span class="line">                                    PutMessageResult putMessageResult = ScheduleMessageService.this.writeMessageStore.putMessage(msgInner);</span><br><span class="line">                                    if (putMessageResult != null &amp;&amp; putMessageResult.getPutMessageStatus() == PutMessageStatus.PUT_OK) &#123;</span><br><span class="line">                                        continue;</span><br><span class="line">                                    &#125; else &#123;</span><br><span class="line">                                        ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), DELAY_FOR_A_PERIOD);</span><br><span class="line">                                        ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);</span><br><span class="line">                                        return;</span><br><span class="line">                                    &#125;</span><br><span class="line">                                &#125; catch (Exception e) &#123;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), countdown);</span><br><span class="line">                            ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);</span><br><span class="line">                            return;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; // end of for</span><br><span class="line">                    nextOffset = offset + (i / ConsumeQueue.CQ_STORE_UNIT_SIZE);</span><br><span class="line">                    ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, nextOffset), DELAY_FOR_A_WHILE);</span><br><span class="line">                    ScheduleMessageService.this.updateOffset(this.delayLevel, nextOffset);</span><br><span class="line">                    return;</span><br><span class="line">                &#125; finally &#123;</span><br><span class="line">                    bufferCQ.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123; // end of if (bufferCQ != null)</span><br><span class="line">                long cqMinOffset = cq.getMinOffsetInQueue();</span><br><span class="line">                if (offset &lt; cqMinOffset) &#123;</span><br><span class="line">                    failScheduleOffset = cqMinOffset;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; // end of if (cq != null)</span><br><span class="line">        ScheduleMessageService.this.timer.schedule(new DeliverDelayedMessageTimerTask(this.delayLevel, failScheduleOffset), DELAY_FOR_A_WHILE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
            </div>
        
        <footer class="article-footer">
        </footer>
    </div>
</article>


    
<nav id="article-nav">
    
        <a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/RocketMQ-%E6%B6%88%E8%B4%B9%E8%80%85%E6%BA%90%E7%A0%81/" id="article-nav-newer" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Newer</strong>
            <div class="article-nav-title">
                
                    RocketMQ-消费者源码
                
            </div>
        </a>
    
    
        <a href="/blog/%E5%B7%A5%E5%85%B7%E5%92%8C%E4%B8%AD%E9%97%B4%E4%BB%B6/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/RocketMQ/RocketMQ-%E5%9F%BA%E7%A1%80/" id="article-nav-older" class="article-nav-link-wrap">
            <strong class="article-nav-caption">Older</strong>
            <div class="article-nav-title">RocketMQ-基础</div>
        </a>
    
</nav>





    
    




<!-- baidu url auto push script -->
<script type="text/javascript">
    !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=window.location.href,o=document.referrer;if(!e.test(r)){var n="//api.share.baidu.com/s.gif";o?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var t=new Image;t.src=n}}(window);
</script>     
</section>
        </div>
        <footer id="footer">
    <div class="outer">
        <div id="footer-info" class="inner">
            Tao Liu &copy; 2022 
            <!-- <a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc-nd/4.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png" /></a> -->
            <br> Powered by <a href="http://hexo.io/" target="_blank" rel="external nofollow noopener noreferrer">Hexo</a>. Theme - <a target="_blank" rel="external nofollow noopener noreferrer" href="https://github.com/taoliu-hub/hexo-theme-Wikitten">wikitten</a>
            <!-- 
                <br>
                <span id="busuanzi_container_site_pv"><i class="fa fa-eye"></i> <span id="busuanzi_value_site_pv"></span></span>
                &nbsp;|&nbsp;
                <span id="busuanzi_container_site_pv"><i class="fa fa-user"></i> <span id="busuanzi_value_site_uv"></span></span>
             -->
        </div>
    </div>
</footer>

        

    
        
<script src="/libs/lightgallery/js/lightgallery.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-thumbnail.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-pager.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-autoplay.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-fullscreen.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-zoom.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-hash.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-share.min.js"></script>

        
<script src="/libs/lightgallery/js/lg-video.min.js"></script>

    
    
        
<script src="/libs/justified-gallery/jquery.justifiedGallery.min.js"></script>

    
    
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true,
            TeX: {
                equationNumbers: {
                  autoNumber: 'AMS'
                }
            }
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script async src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    



<!-- Custom Scripts -->

<script src="/js/main.js"></script>


    </div>
</body>
</html>